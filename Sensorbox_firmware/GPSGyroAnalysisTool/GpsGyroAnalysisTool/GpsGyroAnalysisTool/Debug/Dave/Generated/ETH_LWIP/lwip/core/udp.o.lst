   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "udp.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .data.udp_port,"aw",%progbits
  20              	 .align 1
  23              	udp_port:
  24 0000 00C0     	 .short -16384
  25              	 .comm udp_pcbs,4,4
  26              	 .section .text.udp_init,"ax",%progbits
  27              	 .align 2
  28              	 .global udp_init
  29              	 .thumb
  30              	 .thumb_func
  32              	udp_init:
  33              	.LFB137:
  34              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/core/udp.c"
   1:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * User Datagram Protocol module\n
   4:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * The code for the User Datagram Protocol UDP & UDPLite (RFC 3828).\n
   5:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * See also @ref udp_raw
   6:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
   7:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @defgroup udp_raw UDP
   8:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup callbackstyle_api
   9:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * User Datagram Protocol module\n
  10:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see @ref api
  11:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
  12:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  13:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /*
  14:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  15:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * All rights reserved.
  16:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  17:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  18:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * are permitted provided that the following conditions are met:
  19:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  20:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  21:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *    this list of conditions and the following disclaimer.
  22:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *    this list of conditions and the following disclaimer in the documentation
  24:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *    and/or other materials provided with the distribution.
  25:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 3. The name of the author may not be used to endorse or promote products
  26:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *    derived from this software without specific prior written permission.
  27:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  28:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  29:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  31:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  32:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  33:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  34:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  35:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  36:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  37:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * OF SUCH DAMAGE.
  38:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  39:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * This file is part of the lwIP TCP/IP stack.
  40:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  41:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Author: Adam Dunkels <adam@sics.se>
  42:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  43:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
  44:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  45:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /* @todo Check the use of '(struct udp_pcb).chksum_len_rx'!
  46:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
  47:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  48:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/opt.h"
  49:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  50:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
  51:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  52:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/udp.h"
  53:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/def.h"
  54:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/memp.h"
  55:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/inet_chksum.h"
  56:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/ip_addr.h"
  57:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/ip6.h"
  58:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/ip6_addr.h"
  59:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/netif.h"
  60:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/icmp.h"
  61:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/icmp6.h"
  62:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/stats.h"
  63:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/snmp.h"
  64:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include "ETH_LWIP/lwip/include/lwip/dhcp.h"
  65:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  66:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #include <string.h>
  67:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  68:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #ifndef UDP_LOCAL_PORT_RANGE_START
  69:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /* From http://www.iana.org/assignments/port-numbers:
  70:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    "The Dynamic and/or Private Ports are those from 49152 through 65535" */
  71:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_START  0xc000
  72:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_END    0xffff
  73:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #define UDP_ENSURE_LOCAL_PORT_RANGE(port) ((u16_t)(((port) & (u16_t)~UDP_LOCAL_PORT_RANGE_START) + 
  74:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif
  75:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  76:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /* last local UDP port */
  77:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** static u16_t udp_port = UDP_LOCAL_PORT_RANGE_START;
  78:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  79:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /* The list of UDP PCBs */
  80:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /* exported in udp.h (was static) */
  81:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** struct udp_pcb *udp_pcbs;
  82:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  83:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
  84:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Initialize this module.
  85:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
  86:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
  87:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_init(void)
  88:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
  35              	 .loc 1 88 0
  36              	 .cfi_startproc
  37              	 
  38              	 
  39 0000 80B5     	 push {r7,lr}
  40              	.LCFI0:
  41              	 .cfi_def_cfa_offset 8
  42              	 .cfi_offset 7,-8
  43              	 .cfi_offset 14,-4
  44 0002 00AF     	 add r7,sp,#0
  45              	.LCFI1:
  46              	 .cfi_def_cfa_register 7
  89:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #ifdef LWIP_RAND
  90:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
  47              	 .loc 1 90 0
  48 0004 FFF7FEFF 	 bl rand
  49 0008 0346     	 mov r3,r0
  50 000a 9BB2     	 uxth r3,r3
  51 000c C3F30D03 	 ubfx r3,r3,#0,#14
  52 0010 9BB2     	 uxth r3,r3
  53 0012 A3F58043 	 sub r3,r3,#16384
  54 0016 9AB2     	 uxth r2,r3
  55 0018 014B     	 ldr r3,.L2
  56 001a 1A80     	 strh r2,[r3]
  91:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_RAND */
  92:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
  57              	 .loc 1 92 0
  58 001c 80BD     	 pop {r7,pc}
  59              	.L3:
  60 001e 00BF     	 .align 2
  61              	.L2:
  62 0020 00000000 	 .word udp_port
  63              	 .cfi_endproc
  64              	.LFE137:
  66              	 .section .text.udp_new_port,"ax",%progbits
  67              	 .align 2
  68              	 .thumb
  69              	 .thumb_func
  71              	udp_new_port:
  72              	.LFB138:
  93:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
  94:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
  95:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Allocate a new local UDP port.
  96:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
  97:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return a new (free) local UDP port number
  98:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
  99:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** static u16_t
 100:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_new_port(void)
 101:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
  73              	 .loc 1 101 0
  74              	 .cfi_startproc
  75              	 
  76              	 
  77              	 
  78 0000 80B4     	 push {r7}
  79              	.LCFI2:
  80              	 .cfi_def_cfa_offset 4
  81              	 .cfi_offset 7,-4
  82 0002 83B0     	 sub sp,sp,#12
  83              	.LCFI3:
  84              	 .cfi_def_cfa_offset 16
  85 0004 00AF     	 add r7,sp,#0
  86              	.LCFI4:
  87              	 .cfi_def_cfa_register 7
 102:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u16_t n = 0;
  88              	 .loc 1 102 0
  89 0006 0023     	 movs r3,#0
  90 0008 FB80     	 strh r3,[r7,#6]
  91              	.L5:
 103:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *pcb;
 104:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 105:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** again:
 106:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
  92              	 .loc 1 106 0
  93 000a 184B     	 ldr r3,.L12
  94 000c 1B88     	 ldrh r3,[r3]
  95 000e 5A1C     	 adds r2,r3,#1
  96 0010 91B2     	 uxth r1,r2
  97 0012 164A     	 ldr r2,.L12
  98 0014 1180     	 strh r1,[r2]
  99 0016 4FF6FF72 	 movw r2,#65535
 100 001a 9342     	 cmp r3,r2
 101 001c 03D1     	 bne .L6
 107:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 102              	 .loc 1 107 0
 103 001e 134B     	 ldr r3,.L12
 104 0020 4FF44042 	 mov r2,#49152
 105 0024 1A80     	 strh r2,[r3]
 106              	.L6:
 108:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 109:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Check all PCBs. */
 110:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 107              	 .loc 1 110 0
 108 0026 124B     	 ldr r3,.L12+4
 109 0028 1B68     	 ldr r3,[r3]
 110 002a 3B60     	 str r3,[r7]
 111 002c 12E0     	 b .L7
 112              	.L11:
 111:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb->local_port == udp_port) {
 113              	 .loc 1 111 0
 114 002e 3B68     	 ldr r3,[r7]
 115 0030 5A8A     	 ldrh r2,[r3,#18]
 116 0032 0E4B     	 ldr r3,.L12
 117 0034 1B88     	 ldrh r3,[r3]
 118 0036 9A42     	 cmp r2,r3
 119 0038 09D1     	 bne .L8
 112:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 120              	 .loc 1 112 0
 121 003a FB88     	 ldrh r3,[r7,#6]
 122 003c 0133     	 adds r3,r3,#1
 123 003e FB80     	 strh r3,[r7,#6]
 124 0040 FB88     	 ldrh r3,[r7,#6]
 125 0042 B3F5804F 	 cmp r3,#16384
 126 0046 01D3     	 bcc .L9
 113:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         return 0;
 127              	 .loc 1 113 0
 128 0048 0023     	 movs r3,#0
 129 004a 08E0     	 b .L10
 130              	.L9:
 114:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 115:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       goto again;
 131              	 .loc 1 115 0
 132 004c DDE7     	 b .L5
 133              	.L8:
 110:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb->local_port == udp_port) {
 134              	 .loc 1 110 0 discriminator 2
 135 004e 3B68     	 ldr r3,[r7]
 136 0050 DB68     	 ldr r3,[r3,#12]
 137 0052 3B60     	 str r3,[r7]
 138              	.L7:
 110:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb->local_port == udp_port) {
 139              	 .loc 1 110 0 is_stmt 0 discriminator 1
 140 0054 3B68     	 ldr r3,[r7]
 141 0056 002B     	 cmp r3,#0
 142 0058 E9D1     	 bne .L11
 116:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 117:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 118:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_port;
 143              	 .loc 1 118 0 is_stmt 1
 144 005a 044B     	 ldr r3,.L12
 145 005c 1B88     	 ldrh r3,[r3]
 146              	.L10:
 119:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 147              	 .loc 1 119 0
 148 005e 1846     	 mov r0,r3
 149 0060 0C37     	 adds r7,r7,#12
 150              	.LCFI5:
 151              	 .cfi_def_cfa_offset 4
 152 0062 BD46     	 mov sp,r7
 153              	.LCFI6:
 154              	 .cfi_def_cfa_register 13
 155              	 
 156 0064 5DF8047B 	 ldr r7,[sp],#4
 157              	.LCFI7:
 158              	 .cfi_restore 7
 159              	 .cfi_def_cfa_offset 0
 160 0068 7047     	 bx lr
 161              	.L13:
 162 006a 00BF     	 .align 2
 163              	.L12:
 164 006c 00000000 	 .word udp_port
 165 0070 00000000 	 .word udp_pcbs
 166              	 .cfi_endproc
 167              	.LFE138:
 169              	 .section .text.udp_input_local_match,"ax",%progbits
 170              	 .align 2
 171              	 .thumb
 172              	 .thumb_func
 174              	udp_input_local_match:
 175              	.LFB139:
 120:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 121:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** Common code to see if the current input packet matches the pcb
 122:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * (current input packet is accessed via ip(4/6)_current_* macros)
 123:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 124:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb pcb to check
 125:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param inp network interface on which the datagram was received (only used for IPv4)
 126:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used f
 127:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return 1 on match, 0 otherwise
 128:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 129:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** static u8_t
 130:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
 131:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 176              	 .loc 1 131 0
 177              	 .cfi_startproc
 178              	 
 179              	 
 180              	 
 181 0000 80B4     	 push {r7}
 182              	.LCFI8:
 183              	 .cfi_def_cfa_offset 4
 184              	 .cfi_offset 7,-4
 185 0002 85B0     	 sub sp,sp,#20
 186              	.LCFI9:
 187              	 .cfi_def_cfa_offset 24
 188 0004 00AF     	 add r7,sp,#0
 189              	.LCFI10:
 190              	 .cfi_def_cfa_register 7
 191 0006 F860     	 str r0,[r7,#12]
 192 0008 B960     	 str r1,[r7,#8]
 193 000a 1346     	 mov r3,r2
 194 000c FB71     	 strb r3,[r7,#7]
 132:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
 133:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */
 134:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 135:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 136:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 137:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 138:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* check if PCB is bound to specific netif */
 139:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 195              	 .loc 1 139 0
 196 000e FB68     	 ldr r3,[r7,#12]
 197 0010 1B7A     	 ldrb r3,[r3,#8]
 198 0012 002B     	 cmp r3,#0
 199 0014 0BD0     	 beq .L15
 140:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 200              	 .loc 1 140 0 discriminator 1
 201 0016 FB68     	 ldr r3,[r7,#12]
 202 0018 1A7A     	 ldrb r2,[r3,#8]
 203 001a 1E4B     	 ldr r3,.L21
 204 001c 5B68     	 ldr r3,[r3,#4]
 205 001e 93F83030 	 ldrb r3,[r3,#48]
 206 0022 0133     	 adds r3,r3,#1
 207 0024 DBB2     	 uxtb r3,r3
 139:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 208              	 .loc 1 139 0 discriminator 1
 209 0026 9A42     	 cmp r2,r3
 210 0028 01D0     	 beq .L15
 141:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return 0;
 211              	 .loc 1 141 0
 212 002a 0023     	 movs r3,#0
 213 002c 2BE0     	 b .L16
 214              	.L15:
 142:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 143:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 144:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Dual-stack: PCBs listening to any IP type also listen to any IP address */
 145:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
 146:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && IP_SOF_BROADCAST_RECV
 147:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if ((broadcast != 0) && !ip_get_option(pcb, SOF_BROADCAST)) {
 148:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return 0;
 149:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 150:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 && IP_SOF_BROADCAST_RECV */
 151:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return 1;
 152:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 153:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 154:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Only need to check PCB if incoming IP version matches PCB IP version */
 155:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
 156:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 157:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* Special case: IPv4 broadcast: all or broadcasts in my subnet
 158:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****      * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
 159:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (broadcast != 0) {
 215              	 .loc 1 159 0
 216 002e FB79     	 ldrb r3,[r7,#7]
 217 0030 002B     	 cmp r3,#0
 218 0032 18D0     	 beq .L17
 160:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 161:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (ip_get_option(pcb, SOF_BROADCAST))
 162:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* IP_SOF_BROADCAST_RECV */
 163:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       {
 164:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 219              	 .loc 1 164 0
 220 0034 FB68     	 ldr r3,[r7,#12]
 221 0036 002B     	 cmp r3,#0
 222 0038 13D0     	 beq .L18
 223              	 .loc 1 164 0 is_stmt 0 discriminator 1
 224 003a FB68     	 ldr r3,[r7,#12]
 225 003c 1B68     	 ldr r3,[r3]
 226 003e 002B     	 cmp r3,#0
 227 0040 0FD0     	 beq .L18
 165:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 228              	 .loc 1 165 0 is_stmt 1 discriminator 2
 229 0042 144B     	 ldr r3,.L21
 230 0044 5B69     	 ldr r3,[r3,#20]
 164:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 231              	 .loc 1 164 0 discriminator 2
 232 0046 B3F1FF3F 	 cmp r3,#-1
 233 004a 0AD0     	 beq .L18
 166:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(in
 234              	 .loc 1 166 0
 235 004c FB68     	 ldr r3,[r7,#12]
 236 004e 1A68     	 ldr r2,[r3]
 237 0050 104B     	 ldr r3,.L21
 238 0052 5B69     	 ldr r3,[r3,#20]
 239 0054 5A40     	 eors r2,r2,r3
 240 0056 BB68     	 ldr r3,[r7,#8]
 241 0058 0833     	 adds r3,r3,#8
 242 005a 1B68     	 ldr r3,[r3]
 243 005c 1340     	 ands r3,r3,r2
 165:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 244              	 .loc 1 165 0
 245 005e 002B     	 cmp r3,#0
 246 0060 10D1     	 bne .L19
 247              	.L18:
 167:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           return 1;
 248              	 .loc 1 167 0
 249 0062 0123     	 movs r3,#1
 250 0064 0FE0     	 b .L16
 251              	.L17:
 168:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 169:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 170:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     } else
 171:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 172:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* Handle IPv4 and IPv6: all or exact match */
 173:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 252              	 .loc 1 173 0
 253 0066 FB68     	 ldr r3,[r7,#12]
 254 0068 002B     	 cmp r3,#0
 255 006a 09D0     	 beq .L20
 256              	 .loc 1 173 0 is_stmt 0 discriminator 1
 257 006c FB68     	 ldr r3,[r7,#12]
 258 006e 1B68     	 ldr r3,[r3]
 259 0070 002B     	 cmp r3,#0
 260 0072 05D0     	 beq .L20
 261              	 .loc 1 173 0 discriminator 2
 262 0074 FB68     	 ldr r3,[r7,#12]
 263 0076 1A68     	 ldr r2,[r3]
 264 0078 064B     	 ldr r3,.L21
 265 007a 5B69     	 ldr r3,[r3,#20]
 266 007c 9A42     	 cmp r2,r3
 267 007e 01D1     	 bne .L19
 268              	.L20:
 174:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         return 1;
 269              	 .loc 1 174 0 is_stmt 1
 270 0080 0123     	 movs r3,#1
 271 0082 00E0     	 b .L16
 272              	.L19:
 175:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 176:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 177:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 178:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return 0;
 273              	 .loc 1 178 0
 274 0084 0023     	 movs r3,#0
 275              	.L16:
 179:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 276              	 .loc 1 179 0
 277 0086 1846     	 mov r0,r3
 278 0088 1437     	 adds r7,r7,#20
 279              	.LCFI11:
 280              	 .cfi_def_cfa_offset 4
 281 008a BD46     	 mov sp,r7
 282              	.LCFI12:
 283              	 .cfi_def_cfa_register 13
 284              	 
 285 008c 5DF8047B 	 ldr r7,[sp],#4
 286              	.LCFI13:
 287              	 .cfi_restore 7
 288              	 .cfi_def_cfa_offset 0
 289 0090 7047     	 bx lr
 290              	.L22:
 291 0092 00BF     	 .align 2
 292              	.L21:
 293 0094 00000000 	 .word ip_data
 294              	 .cfi_endproc
 295              	.LFE139:
 297              	 .section .text.udp_input,"ax",%progbits
 298              	 .align 2
 299              	 .global udp_input
 300              	 .thumb
 301              	 .thumb_func
 303              	udp_input:
 304              	.LFB140:
 180:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 181:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
 182:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Process an incoming UDP datagram.
 183:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 184:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Given an incoming UDP datagram (as a chain of pbufs) this function
 185:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * finds a corresponding UDP PCB and hands over the pbuf to the pcbs
 186:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * recv function. If no pcb is found or the datagram is incorrect, the
 187:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * pbuf is freed.
 188:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 189:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param p pbuf to be demultiplexed to a UDP PCB (p->payload pointing to the UDP header)
 190:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param inp network interface on which the datagram was received.
 191:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 192:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 193:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
 194:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_input(struct pbuf *p, struct netif *inp)
 195:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 305              	 .loc 1 195 0
 306              	 .cfi_startproc
 307              	 
 308              	 
 309 0000 90B5     	 push {r4,r7,lr}
 310              	.LCFI14:
 311              	 .cfi_def_cfa_offset 12
 312              	 .cfi_offset 4,-12
 313              	 .cfi_offset 7,-8
 314              	 .cfi_offset 14,-4
 315 0002 8DB0     	 sub sp,sp,#52
 316              	.LCFI15:
 317              	 .cfi_def_cfa_offset 64
 318 0004 02AF     	 add r7,sp,#8
 319              	.LCFI16:
 320              	 .cfi_def_cfa 7,56
 321 0006 7860     	 str r0,[r7,#4]
 322 0008 3960     	 str r1,[r7]
 196:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_hdr *udphdr;
 197:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *pcb, *prev;
 198:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *uncon_pcb;
 199:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u16_t src, dest;
 200:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u8_t broadcast;
 201:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u8_t for_us = 0;
 323              	 .loc 1 201 0
 324 000a 0023     	 movs r3,#0
 325 000c FB76     	 strb r3,[r7,#27]
 202:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 203:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_UNUSED_ARG(inp);
 204:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 205:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 206:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 207:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 208:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 209:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 210:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   PERF_START;
 211:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 212:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   UDP_STATS_INC(udp.recv);
 213:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 214:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Check minimum length (UDP header) */
 215:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (p->len < UDP_HLEN) {
 326              	 .loc 1 215 0
 327 000e 7B68     	 ldr r3,[r7,#4]
 328 0010 5B89     	 ldrh r3,[r3,#10]
 329 0012 072B     	 cmp r3,#7
 330 0014 03D8     	 bhi .L24
 216:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* drop short packets */
 217:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 218:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
 219:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     UDP_STATS_INC(udp.lenerr);
 220:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     UDP_STATS_INC(udp.drop);
 221:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     MIB2_STATS_INC(mib2.udpinerrors);
 222:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pbuf_free(p);
 331              	 .loc 1 222 0
 332 0016 7868     	 ldr r0,[r7,#4]
 333 0018 FFF7FEFF 	 bl pbuf_free
 223:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     goto end;
 334              	 .loc 1 223 0
 335 001c D7E0     	 b .L25
 336              	.L24:
 224:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 225:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 226:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udphdr = (struct udp_hdr *)p->payload;
 337              	 .loc 1 226 0
 338 001e 7B68     	 ldr r3,[r7,#4]
 339 0020 5B68     	 ldr r3,[r3,#4]
 340 0022 7B61     	 str r3,[r7,#20]
 227:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 228:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* is broadcast packet ? */
 229:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 341              	 .loc 1 229 0
 342 0024 6C4B     	 ldr r3,.L44
 343 0026 5A69     	 ldr r2,[r3,#20]
 344 0028 6B4B     	 ldr r3,.L44
 345 002a 1B68     	 ldr r3,[r3]
 346 002c 1046     	 mov r0,r2
 347 002e 1946     	 mov r1,r3
 348 0030 FFF7FEFF 	 bl ip4_addr_isbroadcast_u32
 349 0034 0346     	 mov r3,r0
 350 0036 FB74     	 strb r3,[r7,#19]
 230:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 231:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
 232:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 233:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* convert src and dest ports to host byte order */
 234:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   src = lwip_ntohs(udphdr->src);
 351              	 .loc 1 234 0
 352 0038 7B69     	 ldr r3,[r7,#20]
 353 003a 1B88     	 ldrh r3,[r3]
 354 003c 9BB2     	 uxth r3,r3
 355 003e 1846     	 mov r0,r3
 356 0040 FFF7FEFF 	 bl lwip_htons
 357 0044 0346     	 mov r3,r0
 358 0046 3B82     	 strh r3,[r7,#16]
 235:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   dest = lwip_ntohs(udphdr->dest);
 359              	 .loc 1 235 0
 360 0048 7B69     	 ldr r3,[r7,#20]
 361 004a 5B88     	 ldrh r3,[r3,#2]
 362 004c 9BB2     	 uxth r3,r3
 363 004e 1846     	 mov r0,r3
 364 0050 FFF7FEFF 	 bl lwip_htons
 365 0054 0346     	 mov r3,r0
 366 0056 FB81     	 strh r3,[r7,#14]
 236:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 237:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udp_debug_print(udphdr);
 238:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 239:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* print the UDP source and destination */
 240:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp ("));
 241:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
 242:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
 243:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
 244:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));
 245:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 246:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb = NULL;
 367              	 .loc 1 246 0
 368 0058 0023     	 movs r3,#0
 369 005a 7B62     	 str r3,[r7,#36]
 247:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   prev = NULL;
 370              	 .loc 1 247 0
 371 005c 0023     	 movs r3,#0
 372 005e 3B62     	 str r3,[r7,#32]
 248:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   uncon_pcb = NULL;
 373              	 .loc 1 248 0
 374 0060 0023     	 movs r3,#0
 375 0062 FB61     	 str r3,[r7,#28]
 249:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Iterate through the UDP pcb list for a matching pcb.
 250:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * 'Perfect match' pcbs (connected to the remote port & ip address) are
 251:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * preferred. If no perfect match is found, the first unconnected pcb that
 252:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * matches the local port and ip address gets the datagram. */
 253:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 376              	 .loc 1 253 0
 377 0064 5D4B     	 ldr r3,.L44+4
 378 0066 1B68     	 ldr r3,[r3]
 379 0068 7B62     	 str r3,[r7,#36]
 380 006a 54E0     	 b .L26
 381              	.L33:
 254:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* print the PCB local and remote address */
 255:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("pcb ("));
 256:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->local_ip);
 257:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
 258:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
 259:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
 260:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 261:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* compare PCB local addr+port to UDP destination addr+port */
 262:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if ((pcb->local_port == dest) &&
 382              	 .loc 1 262 0
 383 006c 7B6A     	 ldr r3,[r7,#36]
 384 006e 5B8A     	 ldrh r3,[r3,#18]
 385 0070 FA89     	 ldrh r2,[r7,#14]
 386 0072 9A42     	 cmp r2,r3
 387 0074 4AD1     	 bne .L27
 263:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 388              	 .loc 1 263 0 discriminator 1
 389 0076 FB7C     	 ldrb r3,[r7,#19]
 390 0078 786A     	 ldr r0,[r7,#36]
 391 007a 3968     	 ldr r1,[r7]
 392 007c 1A46     	 mov r2,r3
 393 007e FFF7FEFF 	 bl udp_input_local_match
 394 0082 0346     	 mov r3,r0
 262:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 395              	 .loc 1 262 0 discriminator 1
 396 0084 002B     	 cmp r3,#0
 397 0086 41D0     	 beq .L27
 264:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 398              	 .loc 1 264 0
 399 0088 7B6A     	 ldr r3,[r7,#36]
 400 008a 1B7C     	 ldrb r3,[r3,#16]
 401 008c 03F00403 	 and r3,r3,#4
 402 0090 002B     	 cmp r3,#0
 403 0092 1DD1     	 bne .L28
 265:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (uncon_pcb == NULL) {
 404              	 .loc 1 265 0
 405 0094 FB69     	 ldr r3,[r7,#28]
 406 0096 002B     	 cmp r3,#0
 407 0098 02D1     	 bne .L29
 266:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* the first unconnected matching PCB */
 267:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           uncon_pcb = pcb;
 408              	 .loc 1 267 0
 409 009a 7B6A     	 ldr r3,[r7,#36]
 410 009c FB61     	 str r3,[r7,#28]
 411 009e 17E0     	 b .L28
 412              	.L29:
 268:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 269:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 413              	 .loc 1 269 0
 414 00a0 FB7C     	 ldrb r3,[r7,#19]
 415 00a2 002B     	 cmp r3,#0
 416 00a4 14D0     	 beq .L28
 417              	 .loc 1 269 0 is_stmt 0 discriminator 1
 418 00a6 4C4B     	 ldr r3,.L44
 419 00a8 5B69     	 ldr r3,[r3,#20]
 420 00aa B3F1FF3F 	 cmp r3,#-1
 421 00ae 0FD1     	 bne .L28
 270:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* global broadcast address (only valid for IPv4; match was checked before) */
 271:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), n
 422              	 .loc 1 271 0 is_stmt 1
 423 00b0 FB69     	 ldr r3,[r7,#28]
 424 00b2 1A68     	 ldr r2,[r3]
 425 00b4 3B68     	 ldr r3,[r7]
 426 00b6 0433     	 adds r3,r3,#4
 427 00b8 1B68     	 ldr r3,[r3]
 428 00ba 9A42     	 cmp r2,r3
 429 00bc 08D0     	 beq .L28
 272:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             /* uncon_pcb does not match the input netif, check this pcb */
 273:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_add
 430              	 .loc 1 273 0
 431 00be 7B6A     	 ldr r3,[r7,#36]
 432 00c0 1A68     	 ldr r2,[r3]
 433 00c2 3B68     	 ldr r3,[r7]
 434 00c4 0433     	 adds r3,r3,#4
 435 00c6 1B68     	 ldr r3,[r3]
 436 00c8 9A42     	 cmp r2,r3
 437 00ca 01D1     	 bne .L28
 274:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               /* better match */
 275:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               uncon_pcb = pcb;
 438              	 .loc 1 275 0
 439 00cc 7B6A     	 ldr r3,[r7,#36]
 440 00ce FB61     	 str r3,[r7,#28]
 441              	.L28:
 276:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             }
 277:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
 278:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 279:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 280:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if SO_REUSE
 281:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         else if (!ip_addr_isany(&pcb->local_ip)) {
 282:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* prefer specific IPs over catch-all */
 283:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           uncon_pcb = pcb;
 284:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 285:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* SO_REUSE */
 286:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 287:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 288:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* compare PCB remote addr+port to UDP source addr+port */
 289:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if ((pcb->remote_port == src) &&
 442              	 .loc 1 289 0
 443 00d0 7B6A     	 ldr r3,[r7,#36]
 444 00d2 9B8A     	 ldrh r3,[r3,#20]
 445 00d4 3A8A     	 ldrh r2,[r7,#16]
 446 00d6 9A42     	 cmp r2,r3
 447 00d8 18D1     	 bne .L27
 290:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 448              	 .loc 1 290 0 discriminator 1
 449 00da 7B6A     	 ldr r3,[r7,#36]
 450 00dc 5B68     	 ldr r3,[r3,#4]
 289:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 451              	 .loc 1 289 0 discriminator 1
 452 00de 002B     	 cmp r3,#0
 453 00e0 05D0     	 beq .L30
 291:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 454              	 .loc 1 291 0
 455 00e2 7B6A     	 ldr r3,[r7,#36]
 456 00e4 5A68     	 ldr r2,[r3,#4]
 457 00e6 3C4B     	 ldr r3,.L44
 458 00e8 1B69     	 ldr r3,[r3,#16]
 290:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 459              	 .loc 1 290 0
 460 00ea 9A42     	 cmp r2,r3
 461 00ec 0ED1     	 bne .L27
 462              	.L30:
 292:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* the first fully matching PCB */
 293:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (prev != NULL) {
 463              	 .loc 1 293 0
 464 00ee 3B6A     	 ldr r3,[r7,#32]
 465 00f0 002B     	 cmp r3,#0
 466 00f2 0AD0     	 beq .L31
 294:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* move the pcb to the front of udp_pcbs so that is
 295:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****              found faster next time */
 296:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           prev->next = pcb->next;
 467              	 .loc 1 296 0
 468 00f4 7B6A     	 ldr r3,[r7,#36]
 469 00f6 DA68     	 ldr r2,[r3,#12]
 470 00f8 3B6A     	 ldr r3,[r7,#32]
 471 00fa DA60     	 str r2,[r3,#12]
 297:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           pcb->next = udp_pcbs;
 472              	 .loc 1 297 0
 473 00fc 374B     	 ldr r3,.L44+4
 474 00fe 1A68     	 ldr r2,[r3]
 475 0100 7B6A     	 ldr r3,[r7,#36]
 476 0102 DA60     	 str r2,[r3,#12]
 298:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           udp_pcbs = pcb;
 477              	 .loc 1 298 0
 478 0104 354A     	 ldr r2,.L44+4
 479 0106 7B6A     	 ldr r3,[r7,#36]
 480 0108 1360     	 str r3,[r2]
 481              	.L31:
 299:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         } else {
 300:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           UDP_STATS_INC(udp.cachehit);
 301:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 302:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         break;
 482              	 .loc 1 302 0
 483 010a 07E0     	 b .L32
 484              	.L27:
 303:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 304:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 305:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 306:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     prev = pcb;
 485              	 .loc 1 306 0 discriminator 2
 486 010c 7B6A     	 ldr r3,[r7,#36]
 487 010e 3B62     	 str r3,[r7,#32]
 253:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* print the PCB local and remote address */
 488              	 .loc 1 253 0 discriminator 2
 489 0110 7B6A     	 ldr r3,[r7,#36]
 490 0112 DB68     	 ldr r3,[r3,#12]
 491 0114 7B62     	 str r3,[r7,#36]
 492              	.L26:
 253:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* print the PCB local and remote address */
 493              	 .loc 1 253 0 is_stmt 0 discriminator 1
 494 0116 7B6A     	 ldr r3,[r7,#36]
 495 0118 002B     	 cmp r3,#0
 496 011a A7D1     	 bne .L33
 497              	.L32:
 307:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 308:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* no fully matching pcb found? then look for an unconnected pcb */
 309:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb == NULL) {
 498              	 .loc 1 309 0 is_stmt 1
 499 011c 7B6A     	 ldr r3,[r7,#36]
 500 011e 002B     	 cmp r3,#0
 501 0120 01D1     	 bne .L34
 310:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pcb = uncon_pcb;
 502              	 .loc 1 310 0
 503 0122 FB69     	 ldr r3,[r7,#28]
 504 0124 7B62     	 str r3,[r7,#36]
 505              	.L34:
 311:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 312:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 313:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Check checksum if this is a match or if it was directed at us. */
 314:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb != NULL) {
 506              	 .loc 1 314 0
 507 0126 7B6A     	 ldr r3,[r7,#36]
 508 0128 002B     	 cmp r3,#0
 509 012a 02D0     	 beq .L35
 315:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     for_us = 1;
 510              	 .loc 1 315 0
 511 012c 0123     	 movs r3,#1
 512 012e FB76     	 strb r3,[r7,#27]
 513 0130 0AE0     	 b .L36
 514              	.L35:
 316:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
 317:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6
 318:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (ip_current_is_v6()) {
 319:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
 320:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 321:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 */
 322:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 323:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (!ip_current_is_v6()) {
 324:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 515              	 .loc 1 324 0
 516 0132 3B68     	 ldr r3,[r7]
 517 0134 0433     	 adds r3,r3,#4
 518 0136 1A68     	 ldr r2,[r3]
 519 0138 274B     	 ldr r3,.L44
 520 013a 5B69     	 ldr r3,[r3,#20]
 521 013c 9A42     	 cmp r2,r3
 522 013e 0CBF     	 ite eq
 523 0140 0123     	 moveq r3,#1
 524 0142 0023     	 movne r3,#0
 525 0144 DBB2     	 uxtb r3,r3
 526 0146 FB76     	 strb r3,[r7,#27]
 527              	.L36:
 325:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 326:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 327:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 328:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 329:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (for_us) {
 528              	 .loc 1 329 0
 529 0148 FB7E     	 ldrb r3,[r7,#27]
 530 014a 002B     	 cmp r3,#0
 531 014c 3CD0     	 beq .L37
 330:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 331:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if CHECKSUM_CHECK_UDP
 332:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_UDP) {
 333:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_UDPLITE
 334:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (ip_current_header_proto() == IP_PROTO_UDPLITE) {
 335:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* Do the UDP Lite checksum */
 336:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         u16_t chklen = lwip_ntohs(udphdr->len);
 337:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (chklen < sizeof(struct udp_hdr)) {
 338:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if (chklen == 0) {
 339:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             /* For UDP-Lite, checksum length of 0 means checksum
 340:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                over the complete packet (See RFC 3828 chap. 3.1) */
 341:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             chklen = p->tot_len;
 342:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           } else {
 343:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             /* At least the UDP-Lite header must be covered by the
 344:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                checksum! (Again, see RFC 3828 chap. 3.1) */
 345:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             goto chkerr;
 346:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
 347:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 348:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (ip_chksum_pseudo_partial(p, IP_PROTO_UDPLITE,
 349:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                      p->tot_len, chklen,
 350:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                      ip_current_src_addr(), ip_current_dest_addr()) != 0) {
 351:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           goto chkerr;
 352:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 353:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       } else
 354:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_UDPLITE */
 355:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       {
 356:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (udphdr->chksum != 0) {
 357:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 358:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                ip_current_src_addr(),
 359:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                ip_current_dest_addr()) != 0) {
 360:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             goto chkerr;
 361:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
 362:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 363:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 364:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 365:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 366:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pbuf_remove_header(p, UDP_HLEN)) {
 532              	 .loc 1 366 0
 533 014e 7868     	 ldr r0,[r7,#4]
 534 0150 0821     	 movs r1,#8
 535 0152 FFF7FEFF 	 bl pbuf_remove_header
 536 0156 0346     	 mov r3,r0
 537 0158 002B     	 cmp r3,#0
 538 015a 03D0     	 beq .L38
 367:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* Can we cope with this failing? Just assert for now */
 368:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 369:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       UDP_STATS_INC(udp.drop);
 370:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       MIB2_STATS_INC(mib2.udpinerrors);
 371:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       pbuf_free(p);
 539              	 .loc 1 371 0
 540 015c 7868     	 ldr r0,[r7,#4]
 541 015e FFF7FEFF 	 bl pbuf_free
 372:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       goto end;
 542              	 .loc 1 372 0
 543 0162 34E0     	 b .L25
 544              	.L38:
 373:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 374:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 375:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb != NULL) {
 545              	 .loc 1 375 0
 546 0164 7B6A     	 ldr r3,[r7,#36]
 547 0166 002B     	 cmp r3,#0
 548 0168 13D0     	 beq .L39
 376:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       MIB2_STATS_INC(mib2.udpindatagrams);
 377:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if SO_REUSE && SO_REUSE_RXTOALL
 378:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (ip_get_option(pcb, SOF_REUSEADDR) &&
 379:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           (broadcast || ip_addr_ismulticast(ip_current_dest_addr()))) {
 380:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* pass broadcast- or multicast packets to all multicast pcbs
 381:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****            if SOF_REUSEADDR is set on the first match */
 382:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         struct udp_pcb *mpcb;
 383:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
 384:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if (mpcb != pcb) {
 385:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             /* compare PCB local addr+port to UDP destination addr+port */
 386:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             if ((mpcb->local_port == dest) &&
 387:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 (udp_input_local_match(mpcb, inp, broadcast) != 0)) {
 388:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               /* pass a copy of the packet to all local matches */
 389:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               if (mpcb->recv != NULL) {
 390:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 struct pbuf *q;
 391:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 q = pbuf_clone(PBUF_RAW, PBUF_POOL, p);
 392:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 if (q != NULL) {
 393:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                   mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
 394:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 }
 395:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               }
 396:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             }
 397:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
 398:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 399:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 400:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* SO_REUSE && SO_REUSE_RXTOALL */
 401:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* callback */
 402:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb->recv != NULL) {
 549              	 .loc 1 402 0
 550 016a 7B6A     	 ldr r3,[r7,#36]
 551 016c 9B69     	 ldr r3,[r3,#24]
 552 016e 002B     	 cmp r3,#0
 553 0170 0BD0     	 beq .L40
 403:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* now the recv function is responsible for freeing p */
 404:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 554              	 .loc 1 404 0
 555 0172 7B6A     	 ldr r3,[r7,#36]
 556 0174 9C69     	 ldr r4,[r3,#24]
 557 0176 7B6A     	 ldr r3,[r7,#36]
 558 0178 DA69     	 ldr r2,[r3,#28]
 559 017a 3B8A     	 ldrh r3,[r7,#16]
 560 017c 0093     	 str r3,[sp]
 561 017e 1046     	 mov r0,r2
 562 0180 796A     	 ldr r1,[r7,#36]
 563 0182 7A68     	 ldr r2,[r7,#4]
 564 0184 164B     	 ldr r3,.L44+8
 565 0186 A047     	 blx r4
 566 0188 21E0     	 b .L25
 567              	.L40:
 405:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       } else {
 406:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* no recv function registered? then we have to free the pbuf! */
 407:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         pbuf_free(p);
 568              	 .loc 1 407 0
 569 018a 7868     	 ldr r0,[r7,#4]
 570 018c FFF7FEFF 	 bl pbuf_free
 408:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         goto end;
 571              	 .loc 1 408 0
 572 0190 1DE0     	 b .L25
 573              	.L39:
 409:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 410:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     } else {
 411:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
 412:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 413:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_ICMP || LWIP_ICMP6
 414:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* No match was found, send ICMP destination port unreachable unless
 415:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          destination address was broadcast/multicast. */
 416:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 574              	 .loc 1 416 0
 575 0192 FB7C     	 ldrb r3,[r7,#19]
 576 0194 002B     	 cmp r3,#0
 577 0196 13D1     	 bne .L42
 578              	 .loc 1 416 0 is_stmt 0 discriminator 1
 579 0198 0F4B     	 ldr r3,.L44
 580 019a 5B69     	 ldr r3,[r3,#20]
 581 019c 03F0F003 	 and r3,r3,#240
 582 01a0 E02B     	 cmp r3,#224
 583 01a2 0DD0     	 beq .L42
 417:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* move payload pointer back to ip header */
 418:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 584              	 .loc 1 418 0 is_stmt 1
 585 01a4 0C4B     	 ldr r3,.L44
 586 01a6 9B89     	 ldrh r3,[r3,#12]
 587 01a8 0833     	 adds r3,r3,#8
 588 01aa 9BB2     	 uxth r3,r3
 589 01ac 9BB2     	 uxth r3,r3
 590 01ae 1BB2     	 sxth r3,r3
 591 01b0 7868     	 ldr r0,[r7,#4]
 592 01b2 1946     	 mov r1,r3
 593 01b4 FFF7FEFF 	 bl pbuf_header_force
 419:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 594              	 .loc 1 419 0
 595 01b8 7868     	 ldr r0,[r7,#4]
 596 01ba 0321     	 movs r1,#3
 597 01bc FFF7FEFF 	 bl icmp_dest_unreach
 598              	.L42:
 420:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 421:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_ICMP || LWIP_ICMP6 */
 422:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       UDP_STATS_INC(udp.proterr);
 423:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       UDP_STATS_INC(udp.drop);
 424:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       MIB2_STATS_INC(mib2.udpnoports);
 425:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       pbuf_free(p);
 599              	 .loc 1 425 0
 600 01c0 7868     	 ldr r0,[r7,#4]
 601 01c2 FFF7FEFF 	 bl pbuf_free
 426:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 427:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
 428:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pbuf_free(p);
 429:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 430:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** end:
 431:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   PERF_STOP("udp_input");
 432:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return;
 602              	 .loc 1 432 0
 603 01c6 03E0     	 b .L23
 604              	.L37:
 428:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 605              	 .loc 1 428 0
 606 01c8 7868     	 ldr r0,[r7,#4]
 607 01ca FFF7FEFF 	 bl pbuf_free
 608              	.L25:
 609              	 .loc 1 432 0 discriminator 2
 610 01ce 00BF     	 nop
 611              	.L23:
 433:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if CHECKSUM_CHECK_UDP
 434:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** chkerr:
 435:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 436:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
 437:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   UDP_STATS_INC(udp.chkerr);
 438:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   UDP_STATS_INC(udp.drop);
 439:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   MIB2_STATS_INC(mib2.udpinerrors);
 440:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pbuf_free(p);
 441:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   PERF_STOP("udp_input");
 442:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 443:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 612              	 .loc 1 443 0
 613 01d0 2C37     	 adds r7,r7,#44
 614              	.LCFI17:
 615              	 .cfi_def_cfa_offset 12
 616 01d2 BD46     	 mov sp,r7
 617              	.LCFI18:
 618              	 .cfi_def_cfa_register 13
 619              	 
 620 01d4 90BD     	 pop {r4,r7,pc}
 621              	.L45:
 622 01d6 00BF     	 .align 2
 623              	.L44:
 624 01d8 00000000 	 .word ip_data
 625 01dc 00000000 	 .word udp_pcbs
 626 01e0 10000000 	 .word ip_data+16
 627              	 .cfi_endproc
 628              	.LFE140:
 630              	 .section .text.udp_send,"ax",%progbits
 631              	 .align 2
 632              	 .global udp_send
 633              	 .thumb
 634              	 .thumb_func
 636              	udp_send:
 637              	.LFB141:
 444:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 445:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
 446:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
 447:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Sends the pbuf p using UDP. The pbuf is not deallocated.
 448:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 449:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 450:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 451:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param p chain of pbuf's to be sent.
 452:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 453:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * The datagram will be sent to the current remote_ip & remote_port
 454:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * stored in pcb. If the pcb is not bound to a port, it will
 455:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * automatically be bound to a random port.
 456:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 457:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return lwIP error code.
 458:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_OK. Successful. No error occurred.
 459:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_MEM. Out of memory.
 460:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_RTE. Could not find route to destination address.
 461:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_VAL. No PCB or PCB is dual-stack
 462:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - More errors could be returned by lower protocol layers.
 463:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 464:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect() udp_sendto()
 465:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 466:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 467:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_send(struct udp_pcb *pcb, struct pbuf *p)
 468:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 638              	 .loc 1 468 0
 639              	 .cfi_startproc
 640              	 
 641              	 
 642 0000 80B5     	 push {r7,lr}
 643              	.LCFI19:
 644              	 .cfi_def_cfa_offset 8
 645              	 .cfi_offset 7,-8
 646              	 .cfi_offset 14,-4
 647 0002 82B0     	 sub sp,sp,#8
 648              	.LCFI20:
 649              	 .cfi_def_cfa_offset 16
 650 0004 00AF     	 add r7,sp,#0
 651              	.LCFI21:
 652              	 .cfi_def_cfa_register 7
 653 0006 7860     	 str r0,[r7,#4]
 654 0008 3960     	 str r1,[r7]
 469:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_send: invalid pcb", pcb != NULL, return ERR_ARG);
 655              	 .loc 1 469 0
 656 000a 7B68     	 ldr r3,[r7,#4]
 657 000c 002B     	 cmp r3,#0
 658 000e 01D1     	 bne .L47
 659              	 .loc 1 469 0 is_stmt 0 discriminator 1
 660 0010 F023     	 movs r3,#240
 661 0012 0DE0     	 b .L48
 662              	.L47:
 470:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 663              	 .loc 1 470 0 is_stmt 1
 664 0014 3B68     	 ldr r3,[r7]
 665 0016 002B     	 cmp r3,#0
 666 0018 01D1     	 bne .L49
 667              	 .loc 1 470 0 is_stmt 0 discriminator 1
 668 001a F023     	 movs r3,#240
 669 001c 08E0     	 b .L48
 670              	.L49:
 471:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 472:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
 473:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 474:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 475:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 476:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 477:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 671              	 .loc 1 477 0 is_stmt 1
 672 001e 7B68     	 ldr r3,[r7,#4]
 673 0020 1A1D     	 adds r2,r3,#4
 674 0022 7B68     	 ldr r3,[r7,#4]
 675 0024 9B8A     	 ldrh r3,[r3,#20]
 676 0026 7868     	 ldr r0,[r7,#4]
 677 0028 3968     	 ldr r1,[r7]
 678 002a FFF7FEFF 	 bl udp_sendto
 679 002e 0346     	 mov r3,r0
 680              	.L48:
 681 0030 5BB2     	 sxtb r3,r3
 478:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 682              	 .loc 1 478 0
 683 0032 1846     	 mov r0,r3
 684 0034 0837     	 adds r7,r7,#8
 685              	.LCFI22:
 686              	 .cfi_def_cfa_offset 8
 687 0036 BD46     	 mov sp,r7
 688              	.LCFI23:
 689              	 .cfi_def_cfa_register 13
 690              	 
 691 0038 80BD     	 pop {r7,pc}
 692              	 .cfi_endproc
 693              	.LFE141:
 695 003a 00BF     	 .section .text.udp_sendto,"ax",%progbits
 696              	 .align 2
 697              	 .global udp_sendto
 698              	 .thumb
 699              	 .thumb_func
 701              	udp_sendto:
 702              	.LFB142:
 479:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 480:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 481:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** @ingroup udp_raw
 482:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Same as udp_send() but with checksum
 483:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 484:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 485:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
 486:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 u8_t have_chksum, u16_t chksum)
 487:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 488:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_send_chksum: invalid pcb", pcb != NULL, return ERR_ARG);
 489:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_send_chksum: invalid pbuf", p != NULL, return ERR_ARG);
 490:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 491:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
 492:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 493:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 494:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 495:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 496:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 497:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                            have_chksum, chksum);
 498:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 499:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 500:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 501:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
 502:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
 503:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Send data to a specified address using UDP.
 504:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 505:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 506:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param p chain of pbuf's to be sent.
 507:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param dst_ip Destination IP address.
 508:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param dst_port Destination UDP port.
 509:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 510:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 511:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 512:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * If the PCB already has a remote address association, it will
 513:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * be restored after the data is sent.
 514:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 515:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 516:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 517:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect() udp_send()
 518:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 519:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 520:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
 521:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****            const ip_addr_t *dst_ip, u16_t dst_port)
 522:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 703              	 .loc 1 522 0
 704              	 .cfi_startproc
 705              	 
 706              	 
 707 0000 90B5     	 push {r4,r7,lr}
 708              	.LCFI24:
 709              	 .cfi_def_cfa_offset 12
 710              	 .cfi_offset 4,-12
 711              	 .cfi_offset 7,-8
 712              	 .cfi_offset 14,-4
 713 0002 89B0     	 sub sp,sp,#36
 714              	.LCFI25:
 715              	 .cfi_def_cfa_offset 48
 716 0004 02AF     	 add r7,sp,#8
 717              	.LCFI26:
 718              	 .cfi_def_cfa 7,40
 719 0006 F860     	 str r0,[r7,#12]
 720 0008 B960     	 str r1,[r7,#8]
 721 000a 7A60     	 str r2,[r7,#4]
 722 000c 7B80     	 strh r3,[r7,#2]
 523:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 524:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 525:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 526:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 527:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** @ingroup udp_raw
 528:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Same as udp_sendto(), but with checksum */
 529:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 530:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 531:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                   u16_t dst_port, u8_t have_chksum, u16_t chksum)
 532:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 533:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 534:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct netif *netif;
 535:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 536:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 723              	 .loc 1 536 0
 724 000e FB68     	 ldr r3,[r7,#12]
 725 0010 002B     	 cmp r3,#0
 726 0012 01D1     	 bne .L51
 727              	 .loc 1 536 0 is_stmt 0 discriminator 1
 728 0014 F023     	 movs r3,#240
 729 0016 27E0     	 b .L52
 730              	.L51:
 537:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 731              	 .loc 1 537 0 is_stmt 1
 732 0018 BB68     	 ldr r3,[r7,#8]
 733 001a 002B     	 cmp r3,#0
 734 001c 01D1     	 bne .L53
 735              	 .loc 1 537 0 is_stmt 0 discriminator 1
 736 001e F023     	 movs r3,#240
 737 0020 22E0     	 b .L52
 738              	.L53:
 538:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 739              	 .loc 1 538 0 is_stmt 1
 740 0022 7B68     	 ldr r3,[r7,#4]
 741 0024 002B     	 cmp r3,#0
 742 0026 01D1     	 bne .L54
 743              	 .loc 1 538 0 is_stmt 0 discriminator 1
 744 0028 F023     	 movs r3,#240
 745 002a 1DE0     	 b .L52
 746              	.L54:
 539:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 540:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 541:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 542:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 543:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 544:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
 545:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 546:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb->netif_idx != NETIF_NO_INDEX) {
 747              	 .loc 1 546 0 is_stmt 1
 748 002c FB68     	 ldr r3,[r7,#12]
 749 002e 1B7A     	 ldrb r3,[r3,#8]
 750 0030 002B     	 cmp r3,#0
 751 0032 06D0     	 beq .L55
 547:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 752              	 .loc 1 547 0
 753 0034 FB68     	 ldr r3,[r7,#12]
 754 0036 1B7A     	 ldrb r3,[r3,#8]
 755 0038 1846     	 mov r0,r3
 756 003a FFF7FEFF 	 bl netif_get_by_index
 757 003e 7861     	 str r0,[r7,#20]
 758 0040 03E0     	 b .L56
 759              	.L55:
 548:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
 549:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 550:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     netif = NULL;
 551:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (ip_addr_ismulticast(dst_ip)) {
 552:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* For IPv6, the interface to use for packets with a multicast destination
 553:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * is specified using an interface index. The same approach may be used for
 554:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * IPv4 as well, in which case it overrides the IPv4 multicast override
 555:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * address below. Here we have to look up the netif by going through the
 556:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * list, but by doing so we skip a route lookup. If the interface index has
 557:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * gone stale, we fall through and do the regular route lookup after all. */
 558:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb->mcast_ifindex != NETIF_NO_INDEX) {
 559:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         netif = netif_get_by_index(pcb->mcast_ifindex);
 560:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 561:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 562:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       else
 563:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6
 564:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (IP_IS_V4(dst_ip))
 565:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 */
 566:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         {
 567:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* IPv4 does not use source-based routing by default, so we use an
 568:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****              administratively selected interface for multicast by default.
 569:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****              However, this can be overridden by setting an interface address
 570:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****              in pcb->mcast_ip4 that is used for routing. If this routing lookup
 571:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****              fails, we try regular routing as though no override was set. */
 572:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if (!ip4_addr_isany_val(pcb->mcast_ip4) &&
 573:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               !ip4_addr_cmp(&pcb->mcast_ip4, IP4_ADDR_BROADCAST)) {
 574:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             netif = ip4_route_src(ip_2_ip4(&pcb->local_ip), &pcb->mcast_ip4);
 575:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
 576:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 577:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 578:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 579:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 580:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (netif == NULL)
 581:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 582:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     {
 583:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* find the outgoing network interface for this packet */
 584:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       netif = ip_route(&pcb->local_ip, dst_ip);
 760              	 .loc 1 584 0
 761 0042 7868     	 ldr r0,[r7,#4]
 762 0044 FFF7FEFF 	 bl ip4_route
 763 0048 7861     	 str r0,[r7,#20]
 764              	.L56:
 585:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 586:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 587:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 588:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* no outgoing network interface could be found? */
 589:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (netif == NULL) {
 765              	 .loc 1 589 0
 766 004a 7B69     	 ldr r3,[r7,#20]
 767 004c 002B     	 cmp r3,#0
 768 004e 01D1     	 bne .L57
 590:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 591:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
 592:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("\n"));
 593:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     UDP_STATS_INC(udp.rterr);
 594:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_RTE;
 769              	 .loc 1 594 0
 770 0050 FC23     	 movs r3,#252
 771 0052 09E0     	 b .L52
 772              	.L57:
 595:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 596:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 597:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 598:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 599:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 773              	 .loc 1 599 0
 774 0054 7C88     	 ldrh r4,[r7,#2]
 775 0056 7B69     	 ldr r3,[r7,#20]
 776 0058 0093     	 str r3,[sp]
 777 005a F868     	 ldr r0,[r7,#12]
 778 005c B968     	 ldr r1,[r7,#8]
 779 005e 7A68     	 ldr r2,[r7,#4]
 780 0060 2346     	 mov r3,r4
 781 0062 FFF7FEFF 	 bl udp_sendto_if
 782 0066 0346     	 mov r3,r0
 783              	.L52:
 784 0068 5BB2     	 sxtb r3,r3
 600:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 601:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 785              	 .loc 1 601 0
 786 006a 1846     	 mov r0,r3
 787 006c 1C37     	 adds r7,r7,#28
 788              	.LCFI27:
 789              	 .cfi_def_cfa_offset 12
 790 006e BD46     	 mov sp,r7
 791              	.LCFI28:
 792              	 .cfi_def_cfa_register 13
 793              	 
 794 0070 90BD     	 pop {r4,r7,pc}
 795              	 .cfi_endproc
 796              	.LFE142:
 798 0072 00BF     	 .section .text.udp_sendto_if,"ax",%progbits
 799              	 .align 2
 800              	 .global udp_sendto_if
 801              	 .thumb
 802              	 .thumb_func
 804              	udp_sendto_if:
 805              	.LFB143:
 602:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 603:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
 604:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
 605:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Send data to a specified address using UDP.
 606:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * The netif used for sending can be specified.
 607:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 608:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * This function exists mainly for DHCP, to be able to send UDP packets
 609:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * on a netif that is still down.
 610:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 611:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 612:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param p chain of pbuf's to be sent.
 613:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param dst_ip Destination IP address.
 614:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param dst_port Destination UDP port.
 615:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param netif the netif used for sending.
 616:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 617:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 618:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 619:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 620:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 621:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect() udp_send()
 622:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 623:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 624:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
 625:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 626:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 806              	 .loc 1 626 0
 807              	 .cfi_startproc
 808              	 
 809              	 
 810 0000 90B5     	 push {r4,r7,lr}
 811              	.LCFI29:
 812              	 .cfi_def_cfa_offset 12
 813              	 .cfi_offset 4,-12
 814              	 .cfi_offset 7,-8
 815              	 .cfi_offset 14,-4
 816 0002 89B0     	 sub sp,sp,#36
 817              	.LCFI30:
 818              	 .cfi_def_cfa_offset 48
 819 0004 02AF     	 add r7,sp,#8
 820              	.LCFI31:
 821              	 .cfi_def_cfa 7,40
 822 0006 F860     	 str r0,[r7,#12]
 823 0008 B960     	 str r1,[r7,#8]
 824 000a 7A60     	 str r2,[r7,#4]
 825 000c 7B80     	 strh r3,[r7,#2]
 627:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 628:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 629:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 630:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 631:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** Same as udp_sendto_if(), but with checksum */
 632:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 633:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 634:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                      u16_t dst_port, struct netif *netif, u8_t have_chksum,
 635:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                      u16_t chksum)
 636:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 637:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 638:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   const ip_addr_t *src_ip;
 639:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 640:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 826              	 .loc 1 640 0
 827 000e FB68     	 ldr r3,[r7,#12]
 828 0010 002B     	 cmp r3,#0
 829 0012 01D1     	 bne .L59
 830              	 .loc 1 640 0 is_stmt 0 discriminator 1
 831 0014 F023     	 movs r3,#240
 832 0016 36E0     	 b .L60
 833              	.L59:
 641:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 834              	 .loc 1 641 0 is_stmt 1
 835 0018 BB68     	 ldr r3,[r7,#8]
 836 001a 002B     	 cmp r3,#0
 837 001c 01D1     	 bne .L61
 838              	 .loc 1 641 0 is_stmt 0 discriminator 1
 839 001e F023     	 movs r3,#240
 840 0020 31E0     	 b .L60
 841              	.L61:
 642:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 842              	 .loc 1 642 0 is_stmt 1
 843 0022 7B68     	 ldr r3,[r7,#4]
 844 0024 002B     	 cmp r3,#0
 845 0026 01D1     	 bne .L62
 846              	 .loc 1 642 0 is_stmt 0 discriminator 1
 847 0028 F023     	 movs r3,#240
 848 002a 2CE0     	 b .L60
 849              	.L62:
 643:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 850              	 .loc 1 643 0 is_stmt 1
 851 002c BB6A     	 ldr r3,[r7,#40]
 852 002e 002B     	 cmp r3,#0
 853 0030 01D1     	 bne .L63
 854              	 .loc 1 643 0 is_stmt 0 discriminator 1
 855 0032 F023     	 movs r3,#240
 856 0034 27E0     	 b .L60
 857              	.L63:
 644:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 645:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 646:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 647:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 648:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 649:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* PCB local address is IP_ANY_ADDR or multicast? */
 650:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6
 651:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_V6(dst_ip)) {
 652:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (ip6_addr_isany(ip_2_ip6(&pcb->local_ip)) ||
 653:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         ip6_addr_ismulticast(ip_2_ip6(&pcb->local_ip))) {
 654:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       src_ip = ip6_select_source_address(netif, ip_2_ip6(dst_ip));
 655:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (src_ip == NULL) {
 656:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* No suitable source address was found. */
 657:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         return ERR_RTE;
 658:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 659:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     } else {
 660:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* use UDP PCB local IPv6 address as source address, if still valid. */
 661:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (netif_get_ip6_addr_match(netif, ip_2_ip6(&pcb->local_ip)) < 0) {
 662:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* Address isn't valid anymore. */
 663:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         return ERR_RTE;
 664:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 665:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       src_ip = &pcb->local_ip;
 666:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 667:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 668:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 */
 669:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
 670:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   else
 671:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 && LWIP_IPV6 */
 672:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 673:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 858              	 .loc 1 673 0 is_stmt 1
 859 0036 FB68     	 ldr r3,[r7,#12]
 860 0038 002B     	 cmp r3,#0
 861 003a 09D0     	 beq .L64
 862              	 .loc 1 673 0 is_stmt 0 discriminator 1
 863 003c FB68     	 ldr r3,[r7,#12]
 864 003e 1B68     	 ldr r3,[r3]
 865 0040 002B     	 cmp r3,#0
 866 0042 05D0     	 beq .L64
 674:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 867              	 .loc 1 674 0 is_stmt 1 discriminator 2
 868 0044 FB68     	 ldr r3,[r7,#12]
 869 0046 1B68     	 ldr r3,[r3]
 870 0048 03F0F003 	 and r3,r3,#240
 673:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 871              	 .loc 1 673 0 discriminator 2
 872 004c E02B     	 cmp r3,#224
 873 004e 03D1     	 bne .L65
 874              	.L64:
 675:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* if the local_ip is any or multicast
 676:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * use the outgoing network interface IP address as source address */
 677:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       src_ip = netif_ip_addr4(netif);
 875              	 .loc 1 677 0
 876 0050 BB6A     	 ldr r3,[r7,#40]
 877 0052 0433     	 adds r3,r3,#4
 878 0054 7B61     	 str r3,[r7,#20]
 879 0056 0AE0     	 b .L66
 880              	.L65:
 678:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     } else {
 679:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* check if UDP PCB local IP address is correct
 680:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****        * this could be an old address if netif->ip_addr has changed */
 681:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 881              	 .loc 1 681 0
 882 0058 FB68     	 ldr r3,[r7,#12]
 883 005a 1A68     	 ldr r2,[r3]
 884 005c BB6A     	 ldr r3,[r7,#40]
 885 005e 0433     	 adds r3,r3,#4
 886 0060 1B68     	 ldr r3,[r3]
 887 0062 9A42     	 cmp r2,r3
 888 0064 01D0     	 beq .L67
 682:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 683:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         return ERR_RTE;
 889              	 .loc 1 683 0
 890 0066 FC23     	 movs r3,#252
 891 0068 0DE0     	 b .L60
 892              	.L67:
 684:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 685:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* use UDP PCB local IP address as source address */
 686:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       src_ip = &pcb->local_ip;
 893              	 .loc 1 686 0
 894 006a FB68     	 ldr r3,[r7,#12]
 895 006c 7B61     	 str r3,[r7,#20]
 896              	.L66:
 687:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 688:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 689:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 690:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 691:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 692:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 897              	 .loc 1 692 0
 898 006e 7C88     	 ldrh r4,[r7,#2]
 899 0070 BB6A     	 ldr r3,[r7,#40]
 900 0072 0093     	 str r3,[sp]
 901 0074 7B69     	 ldr r3,[r7,#20]
 902 0076 0193     	 str r3,[sp,#4]
 903 0078 F868     	 ldr r0,[r7,#12]
 904 007a B968     	 ldr r1,[r7,#8]
 905 007c 7A68     	 ldr r2,[r7,#4]
 906 007e 2346     	 mov r3,r4
 907 0080 FFF7FEFF 	 bl udp_sendto_if_src
 908 0084 0346     	 mov r3,r0
 909              	.L60:
 910 0086 5BB2     	 sxtb r3,r3
 693:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 694:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 911              	 .loc 1 694 0
 912 0088 1846     	 mov r0,r3
 913 008a 1C37     	 adds r7,r7,#28
 914              	.LCFI32:
 915              	 .cfi_def_cfa_offset 12
 916 008c BD46     	 mov sp,r7
 917              	.LCFI33:
 918              	 .cfi_def_cfa_register 13
 919              	 
 920 008e 90BD     	 pop {r4,r7,pc}
 921              	 .cfi_endproc
 922              	.LFE143:
 924              	 .section .text.udp_sendto_if_src,"ax",%progbits
 925              	 .align 2
 926              	 .global udp_sendto_if_src
 927              	 .thumb
 928              	 .thumb_func
 930              	udp_sendto_if_src:
 931              	.LFB144:
 695:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 696:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** @ingroup udp_raw
 697:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Same as @ref udp_sendto_if, but with source address */
 698:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 699:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
 700:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 701:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 932              	 .loc 1 701 0
 933              	 .cfi_startproc
 934              	 
 935              	 
 936 0000 90B5     	 push {r4,r7,lr}
 937              	.LCFI34:
 938              	 .cfi_def_cfa_offset 12
 939              	 .cfi_offset 4,-12
 940              	 .cfi_offset 7,-8
 941              	 .cfi_offset 14,-4
 942 0002 8DB0     	 sub sp,sp,#52
 943              	.LCFI35:
 944              	 .cfi_def_cfa_offset 64
 945 0004 04AF     	 add r7,sp,#16
 946              	.LCFI36:
 947              	 .cfi_def_cfa 7,48
 948 0006 F860     	 str r0,[r7,#12]
 949 0008 B960     	 str r1,[r7,#8]
 950 000a 7A60     	 str r2,[r7,#4]
 951 000c 7B80     	 strh r3,[r7,#2]
 702:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 703:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0, src_ip);
 704:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 705:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 706:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** Same as udp_sendto_if_src(), but with checksum */
 707:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 708:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 709:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                          u16_t dst_port, struct netif *netif, u8_t have_chksum,
 710:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                          u16_t chksum, const ip_addr_t *src_ip)
 711:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 712:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 713:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_hdr *udphdr;
 714:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   err_t err;
 715:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 716:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u8_t ip_proto;
 717:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u8_t ttl;
 718:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 719:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 720:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 721:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 952              	 .loc 1 721 0
 953 000e FB68     	 ldr r3,[r7,#12]
 954 0010 002B     	 cmp r3,#0
 955 0012 01D1     	 bne .L69
 956              	 .loc 1 721 0 is_stmt 0 discriminator 1
 957 0014 F023     	 movs r3,#240
 958 0016 90E0     	 b .L70
 959              	.L69:
 722:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 960              	 .loc 1 722 0 is_stmt 1
 961 0018 BB68     	 ldr r3,[r7,#8]
 962 001a 002B     	 cmp r3,#0
 963 001c 01D1     	 bne .L71
 964              	 .loc 1 722 0 is_stmt 0 discriminator 1
 965 001e F023     	 movs r3,#240
 966 0020 8BE0     	 b .L70
 967              	.L71:
 723:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 968              	 .loc 1 723 0 is_stmt 1
 969 0022 7B68     	 ldr r3,[r7,#4]
 970 0024 002B     	 cmp r3,#0
 971 0026 01D1     	 bne .L72
 972              	 .loc 1 723 0 is_stmt 0 discriminator 1
 973 0028 F023     	 movs r3,#240
 974 002a 86E0     	 b .L70
 975              	.L72:
 724:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 976              	 .loc 1 724 0 is_stmt 1
 977 002c 7B6B     	 ldr r3,[r7,#52]
 978 002e 002B     	 cmp r3,#0
 979 0030 01D1     	 bne .L73
 980              	 .loc 1 724 0 is_stmt 0 discriminator 1
 981 0032 F023     	 movs r3,#240
 982 0034 81E0     	 b .L70
 983              	.L73:
 725:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 984              	 .loc 1 725 0 is_stmt 1
 985 0036 3B6B     	 ldr r3,[r7,#48]
 986 0038 002B     	 cmp r3,#0
 987 003a 01D1     	 bne .L74
 988              	 .loc 1 725 0 is_stmt 0 discriminator 1
 989 003c F023     	 movs r3,#240
 990 003e 7CE0     	 b .L70
 991              	.L74:
 726:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 727:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
 728:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 729:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 730:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 731:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 732:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && IP_SOF_BROADCAST
 733:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* broadcast filter? */
 734:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (!ip_get_option(pcb, SOF_BROADCAST) &&
 735:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6
 736:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       IP_IS_V4(dst_ip) &&
 737:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 */
 738:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       ip_addr_isbroadcast(dst_ip, netif)) {
 739:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 740:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
 741:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_VAL;
 742:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 743:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 && IP_SOF_BROADCAST */
 744:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 745:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* if the PCB is not yet bound to a port, bind it here */
 746:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb->local_port == 0) {
 992              	 .loc 1 746 0 is_stmt 1
 993 0040 FB68     	 ldr r3,[r7,#12]
 994 0042 5B8A     	 ldrh r3,[r3,#18]
 995 0044 002B     	 cmp r3,#0
 996 0046 0FD1     	 bne .L75
 747:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 748:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 997              	 .loc 1 748 0
 998 0048 FA68     	 ldr r2,[r7,#12]
 999 004a FB68     	 ldr r3,[r7,#12]
 1000 004c 5B8A     	 ldrh r3,[r3,#18]
 1001 004e F868     	 ldr r0,[r7,#12]
 1002 0050 1146     	 mov r1,r2
 1003 0052 1A46     	 mov r2,r3
 1004 0054 FFF7FEFF 	 bl udp_bind
 1005 0058 0346     	 mov r3,r0
 1006 005a FB76     	 strb r3,[r7,#27]
 749:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (err != ERR_OK) {
 1007              	 .loc 1 749 0
 1008 005c 97F91B30 	 ldrsb r3,[r7,#27]
 1009 0060 002B     	 cmp r3,#0
 1010 0062 01D0     	 beq .L75
 750:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 751:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return err;
 1011              	 .loc 1 751 0
 1012 0064 FB7E     	 ldrb r3,[r7,#27]
 1013 0066 68E0     	 b .L70
 1014              	.L75:
 752:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 753:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 754:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 755:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* packet too large to add a UDP header without causing an overflow? */
 756:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 1015              	 .loc 1 756 0
 1016 0068 BB68     	 ldr r3,[r7,#8]
 1017 006a 1B89     	 ldrh r3,[r3,#8]
 1018 006c 0833     	 adds r3,r3,#8
 1019 006e 9AB2     	 uxth r2,r3
 1020 0070 BB68     	 ldr r3,[r7,#8]
 1021 0072 1B89     	 ldrh r3,[r3,#8]
 1022 0074 9A42     	 cmp r2,r3
 1023 0076 01D2     	 bcs .L76
 757:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     return ERR_MEM;
 1024              	 .loc 1 757 0
 1025 0078 FF23     	 movs r3,#255
 1026 007a 5EE0     	 b .L70
 1027              	.L76:
 758:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 759:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* not enough space to add an UDP header to first pbuf in given p chain? */
 760:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pbuf_add_header(p, UDP_HLEN)) {
 1028              	 .loc 1 760 0
 1029 007c B868     	 ldr r0,[r7,#8]
 1030 007e 0821     	 movs r1,#8
 1031 0080 FFF7FEFF 	 bl pbuf_add_header
 1032 0084 0346     	 mov r3,r0
 1033 0086 002B     	 cmp r3,#0
 1034 0088 14D0     	 beq .L77
 761:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* allocate header in a separate new pbuf */
 762:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 1035              	 .loc 1 762 0
 1036 008a 2420     	 movs r0,#36
 1037 008c 0821     	 movs r1,#8
 1038 008e 4FF42072 	 mov r2,#640
 1039 0092 FFF7FEFF 	 bl pbuf_alloc
 1040 0096 F861     	 str r0,[r7,#28]
 763:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* new header pbuf could not be allocated? */
 764:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (q == NULL) {
 1041              	 .loc 1 764 0
 1042 0098 FB69     	 ldr r3,[r7,#28]
 1043 009a 002B     	 cmp r3,#0
 1044 009c 01D1     	 bne .L78
 765:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 766:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return ERR_MEM;
 1045              	 .loc 1 766 0
 1046 009e FF23     	 movs r3,#255
 1047 00a0 4BE0     	 b .L70
 1048              	.L78:
 767:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 768:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (p->tot_len != 0) {
 1049              	 .loc 1 768 0
 1050 00a2 BB68     	 ldr r3,[r7,#8]
 1051 00a4 1B89     	 ldrh r3,[r3,#8]
 1052 00a6 002B     	 cmp r3,#0
 1053 00a8 06D0     	 beq .L80
 769:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 770:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       pbuf_chain(q, p);
 1054              	 .loc 1 770 0
 1055 00aa F869     	 ldr r0,[r7,#28]
 1056 00ac B968     	 ldr r1,[r7,#8]
 1057 00ae FFF7FEFF 	 bl pbuf_chain
 1058 00b2 01E0     	 b .L80
 1059              	.L77:
 771:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 772:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* first pbuf q points to header pbuf */
 773:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 774:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                 ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
 775:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
 776:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* adding space for header within p succeeded */
 777:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* first pbuf q equals given pbuf */
 778:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     q = p;
 1060              	 .loc 1 778 0
 1061 00b4 BB68     	 ldr r3,[r7,#8]
 1062 00b6 FB61     	 str r3,[r7,#28]
 1063              	.L80:
 779:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
 780:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 781:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 782:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 783:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* q now represents the packet to be sent */
 784:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udphdr = (struct udp_hdr *)q->payload;
 1064              	 .loc 1 784 0
 1065 00b8 FB69     	 ldr r3,[r7,#28]
 1066 00ba 5B68     	 ldr r3,[r3,#4]
 1067 00bc 7B61     	 str r3,[r7,#20]
 785:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 1068              	 .loc 1 785 0
 1069 00be FB68     	 ldr r3,[r7,#12]
 1070 00c0 5B8A     	 ldrh r3,[r3,#18]
 1071 00c2 1846     	 mov r0,r3
 1072 00c4 FFF7FEFF 	 bl lwip_htons
 1073 00c8 0346     	 mov r3,r0
 1074 00ca 1A46     	 mov r2,r3
 1075 00cc 7B69     	 ldr r3,[r7,#20]
 1076 00ce 1A80     	 strh r2,[r3]
 786:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 1077              	 .loc 1 786 0
 1078 00d0 7B88     	 ldrh r3,[r7,#2]
 1079 00d2 1846     	 mov r0,r3
 1080 00d4 FFF7FEFF 	 bl lwip_htons
 1081 00d8 0346     	 mov r3,r0
 1082 00da 1A46     	 mov r2,r3
 1083 00dc 7B69     	 ldr r3,[r7,#20]
 1084 00de 5A80     	 strh r2,[r3,#2]
 787:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 788:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udphdr->chksum = 0x0000;
 1085              	 .loc 1 788 0
 1086 00e0 7B69     	 ldr r3,[r7,#20]
 1087 00e2 0022     	 movs r2,#0
 1088 00e4 9A71     	 strb r2,[r3,#6]
 1089 00e6 0022     	 movs r2,#0
 1090 00e8 DA71     	 strb r2,[r3,#7]
 789:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 790:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Multicast Loop? */
 791:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 792:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
 793:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     q->flags |= PBUF_FLAG_MCASTLOOP;
 794:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 795:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 796:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 797:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
 798:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 799:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_UDPLITE
 800:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* UDP Lite protocol? */
 801:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb->flags & UDP_FLAGS_UDPLITE) {
 802:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     u16_t chklen, chklen_hdr;
 803:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
 804:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* set UDP message length in UDP header */
 805:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     chklen_hdr = chklen = pcb->chksum_len_tx;
 806:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
 807:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (chklen != 0) {
 808:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen
 809:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 810:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* For UDP-Lite, checksum length of 0 means checksum
 811:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          over the complete packet. (See RFC 3828 chap. 3.1)
 812:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          At least the UDP-Lite header must be covered by the
 813:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          checksum, therefore, if chksum_len has an illegal
 814:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          value, we generate the checksum over the complete
 815:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          packet to be safe. */
 816:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       chklen_hdr = 0;
 817:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       chklen = q->tot_len;
 818:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 819:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udphdr->len = lwip_htons(chklen_hdr);
 820:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* calculate checksum */
 821:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if CHECKSUM_GEN_UDP
 822:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
 823:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 824:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (have_chksum) {
 825:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         chklen = UDP_HLEN;
 826:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 827:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 828:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       udphdr->chksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDPLITE,
 829:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                        q->tot_len, chklen, src_ip, dst_ip);
 830:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 831:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (have_chksum) {
 832:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         u32_t acc;
 833:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         acc = udphdr->chksum + (u16_t)~(chksum);
 834:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         udphdr->chksum = FOLD_U32T(acc);
 835:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 836:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 837:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 838:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* chksum zero must become 0xffff, as zero means 'no checksum' */
 839:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (udphdr->chksum == 0x0000) {
 840:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         udphdr->chksum = 0xffff;
 841:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 842:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 843:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 844:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 845:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_proto = IP_PROTO_UDPLITE;
 846:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else
 847:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_UDPLITE */
 848:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   {      /* UDP */
 849:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
 850:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udphdr->len = lwip_htons(q->tot_len);
 1091              	 .loc 1 850 0
 1092 00ea FB69     	 ldr r3,[r7,#28]
 1093 00ec 1B89     	 ldrh r3,[r3,#8]
 1094 00ee 1846     	 mov r0,r3
 1095 00f0 FFF7FEFF 	 bl lwip_htons
 1096 00f4 0346     	 mov r3,r0
 1097 00f6 1A46     	 mov r2,r3
 1098 00f8 7B69     	 ldr r3,[r7,#20]
 1099 00fa 9A80     	 strh r2,[r3,#4]
 851:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* calculate checksum */
 852:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if CHECKSUM_GEN_UDP
 853:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
 854:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* Checksum is mandatory over IPv6. */
 855:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 856:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         u16_t udpchksum;
 857:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 858:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (have_chksum) {
 859:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           u32_t acc;
 860:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 861:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                                q->tot_len, UDP_HLEN, src_ip, dst_ip);
 862:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           acc = udpchksum + (u16_t)~(chksum);
 863:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           udpchksum = FOLD_U32T(acc);
 864:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         } else
 865:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 866:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         {
 867:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 868:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                                        src_ip, dst_ip);
 869:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 870:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 871:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* chksum zero must become 0xffff, as zero means 'no checksum' */
 872:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (udpchksum == 0x0000) {
 873:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           udpchksum = 0xffff;
 874:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
 875:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         udphdr->chksum = udpchksum;
 876:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
 877:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 878:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 879:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_proto = IP_PROTO_UDP;
 1100              	 .loc 1 879 0
 1101 00fc 1123     	 movs r3,#17
 1102 00fe FB74     	 strb r3,[r7,#19]
 880:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 881:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 882:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Determine TTL to use */
 883:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 884:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 885:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #else /* LWIP_MULTICAST_TX_OPTIONS */
 886:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ttl = pcb->ttl;
 1103              	 .loc 1 886 0
 1104 0100 FB68     	 ldr r3,[r7,#12]
 1105 0102 DB7A     	 ldrb r3,[r3,#11]
 1106 0104 BB74     	 strb r3,[r7,#18]
 887:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 888:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 889:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
 890:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
 891:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* output to IP */
 892:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 893:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 1107              	 .loc 1 893 0
 1108 0106 FB68     	 ldr r3,[r7,#12]
 1109 0108 9B7A     	 ldrb r3,[r3,#10]
 1110 010a BC7C     	 ldrb r4,[r7,#18]
 1111 010c 0093     	 str r3,[sp]
 1112 010e FB7C     	 ldrb r3,[r7,#19]
 1113 0110 0193     	 str r3,[sp,#4]
 1114 0112 3B6B     	 ldr r3,[r7,#48]
 1115 0114 0293     	 str r3,[sp,#8]
 1116 0116 F869     	 ldr r0,[r7,#28]
 1117 0118 796B     	 ldr r1,[r7,#52]
 1118 011a 7A68     	 ldr r2,[r7,#4]
 1119 011c 2346     	 mov r3,r4
 1120 011e FFF7FEFF 	 bl ip4_output_if_src
 1121 0122 0346     	 mov r3,r0
 1122 0124 FB76     	 strb r3,[r7,#27]
 894:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   NETIF_RESET_HINTS(netif);
 895:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 896:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* @todo: must this be increased even if error occurred? */
 897:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   MIB2_STATS_INC(mib2.udpoutdatagrams);
 898:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 899:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* did we chain a separate header pbuf earlier? */
 900:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (q != p) {
 1123              	 .loc 1 900 0
 1124 0126 FA69     	 ldr r2,[r7,#28]
 1125 0128 BB68     	 ldr r3,[r7,#8]
 1126 012a 9A42     	 cmp r2,r3
 1127 012c 04D0     	 beq .L81
 901:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* free the header pbuf */
 902:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pbuf_free(q);
 1128              	 .loc 1 902 0
 1129 012e F869     	 ldr r0,[r7,#28]
 1130 0130 FFF7FEFF 	 bl pbuf_free
 903:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     q = NULL;
 1131              	 .loc 1 903 0
 1132 0134 0023     	 movs r3,#0
 1133 0136 FB61     	 str r3,[r7,#28]
 1134              	.L81:
 904:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 905:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 906:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 907:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   UDP_STATS_INC(udp.xmit);
 908:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return err;
 1135              	 .loc 1 908 0
 1136 0138 FB7E     	 ldrb r3,[r7,#27]
 1137              	.L70:
 1138 013a 5BB2     	 sxtb r3,r3
 909:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1139              	 .loc 1 909 0
 1140 013c 1846     	 mov r0,r3
 1141 013e 2437     	 adds r7,r7,#36
 1142              	.LCFI37:
 1143              	 .cfi_def_cfa_offset 12
 1144 0140 BD46     	 mov sp,r7
 1145              	.LCFI38:
 1146              	 .cfi_def_cfa_register 13
 1147              	 
 1148 0142 90BD     	 pop {r4,r7,pc}
 1149              	 .cfi_endproc
 1150              	.LFE144:
 1152              	 .section .text.udp_bind,"ax",%progbits
 1153              	 .align 2
 1154              	 .global udp_bind
 1155              	 .thumb
 1156              	 .thumb_func
 1158              	udp_bind:
 1159              	.LFB145:
 910:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 911:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
 912:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
 913:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Bind an UDP PCB.
 914:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 
 915:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 916:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param ipaddr local IP address to bind with. Use IP_ANY_TYPE to
 917:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * bind to all local interfaces.
 918:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param port local UDP port to bind with. Use 0 to automatically bind
 919:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * to a random port between UDP_LOCAL_PORT_RANGE_START and
 920:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * UDP_LOCAL_PORT_RANGE_END.
 921:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 922:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
 923:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 924:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return lwIP error code.
 925:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_OK. Successful. No error occurred.
 926:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * - ERR_USE. The specified ipaddr and port are already bound to by
 927:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * another UDP PCB.
 928:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
 929:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect()
 930:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
 931:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
 932:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
 933:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1160              	 .loc 1 933 0
 1161              	 .cfi_startproc
 1162              	 
 1163              	 
 1164 0000 80B5     	 push {r7,lr}
 1165              	.LCFI39:
 1166              	 .cfi_def_cfa_offset 8
 1167              	 .cfi_offset 7,-8
 1168              	 .cfi_offset 14,-4
 1169 0002 86B0     	 sub sp,sp,#24
 1170              	.LCFI40:
 1171              	 .cfi_def_cfa_offset 32
 1172 0004 00AF     	 add r7,sp,#0
 1173              	.LCFI41:
 1174              	 .cfi_def_cfa_register 7
 1175 0006 F860     	 str r0,[r7,#12]
 1176 0008 B960     	 str r1,[r7,#8]
 1177 000a 1346     	 mov r3,r2
 1178 000c FB80     	 strh r3,[r7,#6]
 934:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *ipcb;
 935:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   u8_t rebind;
 936:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 937:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_t zoned_ipaddr;
 938:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
 939:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 940:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 941:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 942:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4
 943:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
 944:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (ipaddr == NULL) {
 1179              	 .loc 1 944 0
 1180 000e BB68     	 ldr r3,[r7,#8]
 1181 0010 002B     	 cmp r3,#0
 1182 0012 01D1     	 bne .L83
 945:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ipaddr = IP4_ADDR_ANY;
 1183              	 .loc 1 945 0
 1184 0014 354B     	 ldr r3,.L99
 1185 0016 BB60     	 str r3,[r7,#8]
 1186              	.L83:
 946:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 947:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #else /* LWIP_IPV4 */
 948:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 949:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 */
 950:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 951:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 1187              	 .loc 1 951 0
 1188 0018 FB68     	 ldr r3,[r7,#12]
 1189 001a 002B     	 cmp r3,#0
 1190 001c 01D1     	 bne .L84
 1191              	 .loc 1 951 0 is_stmt 0 discriminator 1
 1192 001e F023     	 movs r3,#240
 1193 0020 5EE0     	 b .L85
 1194              	.L84:
 952:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 953:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
 954:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
 955:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
 956:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 957:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   rebind = 0;
 1195              	 .loc 1 957 0 is_stmt 1
 1196 0022 0023     	 movs r3,#0
 1197 0024 FB74     	 strb r3,[r7,#19]
 958:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Check for double bind and rebind of the same pcb */
 959:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1198              	 .loc 1 959 0
 1199 0026 324B     	 ldr r3,.L99+4
 1200 0028 1B68     	 ldr r3,[r3]
 1201 002a 7B61     	 str r3,[r7,#20]
 1202 002c 09E0     	 b .L86
 1203              	.L89:
 960:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* is this UDP PCB already on active list? */
 961:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb == ipcb) {
 1204              	 .loc 1 961 0
 1205 002e FA68     	 ldr r2,[r7,#12]
 1206 0030 7B69     	 ldr r3,[r7,#20]
 1207 0032 9A42     	 cmp r2,r3
 1208 0034 02D1     	 bne .L87
 962:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       rebind = 1;
 1209              	 .loc 1 962 0
 1210 0036 0123     	 movs r3,#1
 1211 0038 FB74     	 strb r3,[r7,#19]
 963:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       break;
 1212              	 .loc 1 963 0
 1213 003a 05E0     	 b .L88
 1214              	.L87:
 959:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* is this UDP PCB already on active list? */
 1215              	 .loc 1 959 0 discriminator 2
 1216 003c 7B69     	 ldr r3,[r7,#20]
 1217 003e DB68     	 ldr r3,[r3,#12]
 1218 0040 7B61     	 str r3,[r7,#20]
 1219              	.L86:
 959:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* is this UDP PCB already on active list? */
 1220              	 .loc 1 959 0 is_stmt 0 discriminator 1
 1221 0042 7B69     	 ldr r3,[r7,#20]
 1222 0044 002B     	 cmp r3,#0
 1223 0046 F2D1     	 bne .L89
 1224              	.L88:
 964:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 965:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 966:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 967:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 968:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* If the given IP address should have a zone but doesn't, assign one now.
 969:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * This is legacy support: scope-aware callers should always provide properly
 970:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * zoned source addresses. Do the zone selection before the address-in-use
 971:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * check below; as such we have to make a temporary copy of the address. */
 972:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_V6(ipaddr) && ip6_addr_lacks_zone(ip_2_ip6(ipaddr), IP6_UNKNOWN)) {
 973:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_copy(zoned_ipaddr, *ipaddr);
 974:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
 975:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ipaddr = &zoned_ipaddr;
 976:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
 977:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
 978:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
 979:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* no port specified? */
 980:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (port == 0) {
 1225              	 .loc 1 980 0 is_stmt 1
 1226 0048 FB88     	 ldrh r3,[r7,#6]
 1227 004a 002B     	 cmp r3,#0
 1228 004c 08D1     	 bne .L90
 981:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     port = udp_new_port();
 1229              	 .loc 1 981 0
 1230 004e FFF7FEFF 	 bl udp_new_port
 1231 0052 0346     	 mov r3,r0
 1232 0054 FB80     	 strh r3,[r7,#6]
 982:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (port == 0) {
 1233              	 .loc 1 982 0
 1234 0056 FB88     	 ldrh r3,[r7,#6]
 1235 0058 002B     	 cmp r3,#0
 1236 005a 2AD1     	 bne .L91
 983:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* no more ports available in local range */
 984:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
 985:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return ERR_USE;
 1237              	 .loc 1 985 0
 1238 005c F823     	 movs r3,#248
 1239 005e 3FE0     	 b .L85
 1240              	.L90:
 986:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
 987:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
 988:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1241              	 .loc 1 988 0
 1242 0060 234B     	 ldr r3,.L99+4
 1243 0062 1B68     	 ldr r3,[r3]
 1244 0064 7B61     	 str r3,[r7,#20]
 1245 0066 21E0     	 b .L92
 1246              	.L95:
 989:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb != ipcb) {
 1247              	 .loc 1 989 0
 1248 0068 FA68     	 ldr r2,[r7,#12]
 1249 006a 7B69     	 ldr r3,[r7,#20]
 1250 006c 9A42     	 cmp r2,r3
 1251 006e 1AD0     	 beq .L93
 990:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* By default, we don't allow to bind to a port that any other udp
 991:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****            PCB is already bound to, unless *all* PCBs with that port have tha
 992:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****            REUSEADDR flag set. */
 993:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if SO_REUSE
 994:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 995:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             !ip_get_option(ipcb, SOF_REUSEADDR))
 996:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* SO_REUSE */
 997:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         {
 998:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           /* port matches that of PCB in list and REUSEADDR not set -> reject */
 999:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           if ((ipcb->local_port == port) &&
 1252              	 .loc 1 999 0
 1253 0070 7B69     	 ldr r3,[r7,#20]
 1254 0072 5B8A     	 ldrh r3,[r3,#18]
 1255 0074 FA88     	 ldrh r2,[r7,#6]
 1256 0076 9A42     	 cmp r2,r3
 1257 0078 15D1     	 bne .L93
1000:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               /* IP address matches or any IP used? */
1001:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 1258              	 .loc 1 1001 0 discriminator 1
 1259 007a 7B69     	 ldr r3,[r7,#20]
 1260 007c 1A68     	 ldr r2,[r3]
 1261 007e BB68     	 ldr r3,[r7,#8]
 1262 0080 1B68     	 ldr r3,[r3]
 999:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               /* IP address matches or any IP used? */
 1263              	 .loc 1 999 0 discriminator 1
 1264 0082 9A42     	 cmp r2,r3
 1265 0084 0DD0     	 beq .L94
 1266              	 .loc 1 1001 0
 1267 0086 BB68     	 ldr r3,[r7,#8]
 1268 0088 002B     	 cmp r3,#0
 1269 008a 0AD0     	 beq .L94
 1270              	 .loc 1 1001 0 is_stmt 0 discriminator 1
 1271 008c BB68     	 ldr r3,[r7,#8]
 1272 008e 1B68     	 ldr r3,[r3]
 1273 0090 002B     	 cmp r3,#0
 1274 0092 06D0     	 beq .L94
1002:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               ip_addr_isany(&ipcb->local_ip))) {
 1275              	 .loc 1 1002 0 is_stmt 1 discriminator 2
 1276 0094 7B69     	 ldr r3,[r7,#20]
1001:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****               ip_addr_isany(&ipcb->local_ip))) {
 1277              	 .loc 1 1001 0 discriminator 2
 1278 0096 002B     	 cmp r3,#0
 1279 0098 03D0     	 beq .L94
 1280              	 .loc 1 1002 0
 1281 009a 7B69     	 ldr r3,[r7,#20]
 1282 009c 1B68     	 ldr r3,[r3]
 1283 009e 002B     	 cmp r3,#0
 1284 00a0 01D1     	 bne .L93
 1285              	.L94:
1003:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             /* other PCB already binds to this local IP and port */
1004:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             LWIP_DEBUGF(UDP_DEBUG,
1005:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                         ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
1006:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****             return ERR_USE;
 1286              	 .loc 1 1006 0
 1287 00a2 F823     	 movs r3,#248
 1288 00a4 1CE0     	 b .L85
 1289              	.L93:
 988:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb != ipcb) {
 1290              	 .loc 1 988 0 discriminator 2
 1291 00a6 7B69     	 ldr r3,[r7,#20]
 1292 00a8 DB68     	 ldr r3,[r3,#12]
 1293 00aa 7B61     	 str r3,[r7,#20]
 1294              	.L92:
 988:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb != ipcb) {
 1295              	 .loc 1 988 0 is_stmt 0 discriminator 1
 1296 00ac 7B69     	 ldr r3,[r7,#20]
 1297 00ae 002B     	 cmp r3,#0
 1298 00b0 DAD1     	 bne .L95
 1299              	.L91:
1007:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****           }
1008:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         }
1009:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
1010:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
1011:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1012:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1013:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 1300              	 .loc 1 1013 0 is_stmt 1
 1301 00b2 BB68     	 ldr r3,[r7,#8]
 1302 00b4 002B     	 cmp r3,#0
 1303 00b6 02D0     	 beq .L96
 1304              	 .loc 1 1013 0 is_stmt 0 discriminator 1
 1305 00b8 BB68     	 ldr r3,[r7,#8]
 1306 00ba 1B68     	 ldr r3,[r3]
 1307 00bc 00E0     	 b .L97
 1308              	.L96:
 1309              	 .loc 1 1013 0 discriminator 2
 1310 00be 0023     	 movs r3,#0
 1311              	.L97:
 1312              	 .loc 1 1013 0 discriminator 4
 1313 00c0 FA68     	 ldr r2,[r7,#12]
 1314 00c2 1360     	 str r3,[r2]
1014:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1015:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->local_port = port;
 1315              	 .loc 1 1015 0 is_stmt 1 discriminator 4
 1316 00c4 FB68     	 ldr r3,[r7,#12]
 1317 00c6 FA88     	 ldrh r2,[r7,#6]
 1318 00c8 5A82     	 strh r2,[r3,#18]
1016:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   mib2_udp_bind(pcb);
1017:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* pcb not active yet? */
1018:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (rebind == 0) {
 1319              	 .loc 1 1018 0 discriminator 4
 1320 00ca FB7C     	 ldrb r3,[r7,#19]
 1321 00cc 002B     	 cmp r3,#0
 1322 00ce 06D1     	 bne .L98
1019:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* place the PCB on the active list if not already there */
1020:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pcb->next = udp_pcbs;
 1323              	 .loc 1 1020 0
 1324 00d0 074B     	 ldr r3,.L99+4
 1325 00d2 1A68     	 ldr r2,[r3]
 1326 00d4 FB68     	 ldr r3,[r7,#12]
 1327 00d6 DA60     	 str r2,[r3,#12]
1021:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udp_pcbs = pcb;
 1328              	 .loc 1 1021 0
 1329 00d8 054A     	 ldr r2,.L99+4
 1330 00da FB68     	 ldr r3,[r7,#12]
 1331 00dc 1360     	 str r3,[r2]
 1332              	.L98:
1022:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1023:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
1024:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
1025:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port))
1026:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return ERR_OK;
 1333              	 .loc 1 1026 0
 1334 00de 0023     	 movs r3,#0
 1335              	.L85:
 1336 00e0 5BB2     	 sxtb r3,r3
1027:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1337              	 .loc 1 1027 0
 1338 00e2 1846     	 mov r0,r3
 1339 00e4 1837     	 adds r7,r7,#24
 1340              	.LCFI42:
 1341              	 .cfi_def_cfa_offset 8
 1342 00e6 BD46     	 mov sp,r7
 1343              	.LCFI43:
 1344              	 .cfi_def_cfa_register 13
 1345              	 
 1346 00e8 80BD     	 pop {r7,pc}
 1347              	.L100:
 1348 00ea 00BF     	 .align 2
 1349              	.L99:
 1350 00ec 00000000 	 .word ip_addr_any
 1351 00f0 00000000 	 .word udp_pcbs
 1352              	 .cfi_endproc
 1353              	.LFE145:
 1355              	 .section .text.udp_bind_netif,"ax",%progbits
 1356              	 .align 2
 1357              	 .global udp_bind_netif
 1358              	 .thumb
 1359              	 .thumb_func
 1361              	udp_bind_netif:
 1362              	.LFB146:
1028:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1029:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1030:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1031:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Bind an UDP PCB to a specific netif.
1032:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * After calling this function, all packets received via this PCB
1033:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * are guaranteed to have come in via the specified netif, and all
1034:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * outgoing packets will go out via the specified netif.
1035:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1036:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB to be bound.
1037:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param netif netif to bind udp pcb to. Can be NULL.
1038:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1039:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect()
1040:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1041:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
1042:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_bind_netif(struct udp_pcb *pcb, const struct netif *netif)
1043:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1363              	 .loc 1 1043 0
 1364              	 .cfi_startproc
 1365              	 
 1366              	 
 1367              	 
 1368 0000 80B4     	 push {r7}
 1369              	.LCFI44:
 1370              	 .cfi_def_cfa_offset 4
 1371              	 .cfi_offset 7,-4
 1372 0002 83B0     	 sub sp,sp,#12
 1373              	.LCFI45:
 1374              	 .cfi_def_cfa_offset 16
 1375 0004 00AF     	 add r7,sp,#0
 1376              	.LCFI46:
 1377              	 .cfi_def_cfa_register 7
 1378 0006 7860     	 str r0,[r7,#4]
 1379 0008 3960     	 str r1,[r7]
1044:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1045:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1046:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (netif != NULL) {
 1380              	 .loc 1 1046 0
 1381 000a 3B68     	 ldr r3,[r7]
 1382 000c 002B     	 cmp r3,#0
 1383 000e 07D0     	 beq .L102
1047:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pcb->netif_idx = netif_get_index(netif);
 1384              	 .loc 1 1047 0
 1385 0010 3B68     	 ldr r3,[r7]
 1386 0012 93F83030 	 ldrb r3,[r3,#48]
 1387 0016 0133     	 adds r3,r3,#1
 1388 0018 DAB2     	 uxtb r2,r3
 1389 001a 7B68     	 ldr r3,[r7,#4]
 1390 001c 1A72     	 strb r2,[r3,#8]
 1391 001e 02E0     	 b .L101
 1392              	.L102:
1048:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
1049:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pcb->netif_idx = NETIF_NO_INDEX;
 1393              	 .loc 1 1049 0
 1394 0020 7B68     	 ldr r3,[r7,#4]
 1395 0022 0022     	 movs r2,#0
 1396 0024 1A72     	 strb r2,[r3,#8]
 1397              	.L101:
1050:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1051:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1398              	 .loc 1 1051 0
 1399 0026 0C37     	 adds r7,r7,#12
 1400              	.LCFI47:
 1401              	 .cfi_def_cfa_offset 4
 1402 0028 BD46     	 mov sp,r7
 1403              	.LCFI48:
 1404              	 .cfi_def_cfa_register 13
 1405              	 
 1406 002a 5DF8047B 	 ldr r7,[sp],#4
 1407              	.LCFI49:
 1408              	 .cfi_restore 7
 1409              	 .cfi_def_cfa_offset 0
 1410 002e 7047     	 bx lr
 1411              	 .cfi_endproc
 1412              	.LFE146:
 1414              	 .section .text.udp_connect,"ax",%progbits
 1415              	 .align 2
 1416              	 .global udp_connect
 1417              	 .thumb
 1418              	 .thumb_func
 1420              	udp_connect:
 1421              	.LFB147:
1052:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1053:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1054:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1055:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Sets the remote end of the pcb. This function does not generate any
1056:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * network traffic, but only sets the remote address of the pcb.
1057:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1058:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB to be connected with remote address ipaddr and port.
1059:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param ipaddr remote IP address to connect with.
1060:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param port remote UDP port to connect with.
1061:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1062:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return lwIP error code
1063:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1064:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
1065:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1066:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * The udp pcb is bound to a random local port if not already bound.
1067:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1068:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_disconnect()
1069:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1070:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** err_t
1071:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
1072:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1422              	 .loc 1 1072 0
 1423              	 .cfi_startproc
 1424              	 
 1425              	 
 1426 0000 80B5     	 push {r7,lr}
 1427              	.LCFI50:
 1428              	 .cfi_def_cfa_offset 8
 1429              	 .cfi_offset 7,-8
 1430              	 .cfi_offset 14,-4
 1431 0002 86B0     	 sub sp,sp,#24
 1432              	.LCFI51:
 1433              	 .cfi_def_cfa_offset 32
 1434 0004 00AF     	 add r7,sp,#0
 1435              	.LCFI52:
 1436              	 .cfi_def_cfa_register 7
 1437 0006 F860     	 str r0,[r7,#12]
 1438 0008 B960     	 str r1,[r7,#8]
 1439 000a 1346     	 mov r3,r2
 1440 000c FB80     	 strh r3,[r7,#6]
1073:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *ipcb;
1074:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1075:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1076:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1077:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 1441              	 .loc 1 1077 0
 1442 000e FB68     	 ldr r3,[r7,#12]
 1443 0010 002B     	 cmp r3,#0
 1444 0012 01D1     	 bne .L105
 1445              	 .loc 1 1077 0 is_stmt 0 discriminator 1
 1446 0014 F023     	 movs r3,#240
 1447 0016 43E0     	 b .L106
 1448              	.L105:
1078:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 1449              	 .loc 1 1078 0 is_stmt 1
 1450 0018 BB68     	 ldr r3,[r7,#8]
 1451 001a 002B     	 cmp r3,#0
 1452 001c 01D1     	 bne .L107
 1453              	 .loc 1 1078 0 is_stmt 0 discriminator 1
 1454 001e F023     	 movs r3,#240
 1455 0020 3EE0     	 b .L106
 1456              	.L107:
1079:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1080:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb->local_port == 0) {
 1457              	 .loc 1 1080 0 is_stmt 1
 1458 0022 FB68     	 ldr r3,[r7,#12]
 1459 0024 5B8A     	 ldrh r3,[r3,#18]
 1460 0026 002B     	 cmp r3,#0
 1461 0028 0FD1     	 bne .L108
 1462              	.LBB2:
1081:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 1463              	 .loc 1 1081 0
 1464 002a FA68     	 ldr r2,[r7,#12]
 1465 002c FB68     	 ldr r3,[r7,#12]
 1466 002e 5B8A     	 ldrh r3,[r3,#18]
 1467 0030 F868     	 ldr r0,[r7,#12]
 1468 0032 1146     	 mov r1,r2
 1469 0034 1A46     	 mov r2,r3
 1470 0036 FFF7FEFF 	 bl udp_bind
 1471 003a 0346     	 mov r3,r0
 1472 003c FB74     	 strb r3,[r7,#19]
1082:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (err != ERR_OK) {
 1473              	 .loc 1 1082 0
 1474 003e 97F91330 	 ldrsb r3,[r7,#19]
 1475 0042 002B     	 cmp r3,#0
 1476 0044 01D0     	 beq .L108
1083:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return err;
 1477              	 .loc 1 1083 0
 1478 0046 FB7C     	 ldrb r3,[r7,#19]
 1479 0048 2AE0     	 b .L106
 1480              	.L108:
 1481              	.LBE2:
1084:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
1085:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1086:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1087:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 1482              	 .loc 1 1087 0
 1483 004a BB68     	 ldr r3,[r7,#8]
 1484 004c 002B     	 cmp r3,#0
 1485 004e 02D0     	 beq .L109
 1486              	 .loc 1 1087 0 is_stmt 0 discriminator 1
 1487 0050 BB68     	 ldr r3,[r7,#8]
 1488 0052 1B68     	 ldr r3,[r3]
 1489 0054 00E0     	 b .L110
 1490              	.L109:
 1491              	 .loc 1 1087 0 discriminator 2
 1492 0056 0023     	 movs r3,#0
 1493              	.L110:
 1494              	 .loc 1 1087 0 discriminator 4
 1495 0058 FA68     	 ldr r2,[r7,#12]
 1496 005a 5360     	 str r3,[r2,#4]
1088:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
1089:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* If the given IP address should have a zone but doesn't, assign one now,
1090:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****    * using the bound address to make a more informed decision when possible. */
1091:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_V6(&pcb->remote_ip) &&
1092:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
1093:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
1094:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1095:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
1096:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1097:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->remote_port = port;
 1497              	 .loc 1 1097 0 is_stmt 1 discriminator 4
 1498 005c FB68     	 ldr r3,[r7,#12]
 1499 005e FA88     	 ldrh r2,[r7,#6]
 1500 0060 9A82     	 strh r2,[r3,#20]
1098:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->flags |= UDP_FLAGS_CONNECTED;
 1501              	 .loc 1 1098 0 discriminator 4
 1502 0062 FB68     	 ldr r3,[r7,#12]
 1503 0064 1B7C     	 ldrb r3,[r3,#16]
 1504 0066 43F00403 	 orr r3,r3,#4
 1505 006a DAB2     	 uxtb r2,r3
 1506 006c FB68     	 ldr r3,[r7,#12]
 1507 006e 1A74     	 strb r2,[r3,#16]
1099:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1100:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_connect: connected to "));
1101:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
1102:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****                           pcb->remote_ip);
1103:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port)
1104:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1105:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* Insert UDP PCB into the list of active UDP PCBs. */
1106:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1508              	 .loc 1 1106 0 discriminator 4
 1509 0070 0E4B     	 ldr r3,.L114
 1510 0072 1B68     	 ldr r3,[r3]
 1511 0074 7B61     	 str r3,[r7,#20]
 1512 0076 08E0     	 b .L111
 1513              	.L113:
1107:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb == ipcb) {
 1514              	 .loc 1 1107 0
 1515 0078 FA68     	 ldr r2,[r7,#12]
 1516 007a 7B69     	 ldr r3,[r7,#20]
 1517 007c 9A42     	 cmp r2,r3
 1518 007e 01D1     	 bne .L112
1108:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* already on the list, just return */
1109:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       return ERR_OK;
 1519              	 .loc 1 1109 0
 1520 0080 0023     	 movs r3,#0
 1521 0082 0DE0     	 b .L106
 1522              	.L112:
1106:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb == ipcb) {
 1523              	 .loc 1 1106 0 discriminator 2
 1524 0084 7B69     	 ldr r3,[r7,#20]
 1525 0086 DB68     	 ldr r3,[r3,#12]
 1526 0088 7B61     	 str r3,[r7,#20]
 1527              	.L111:
1106:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     if (pcb == ipcb) {
 1528              	 .loc 1 1106 0 is_stmt 0 discriminator 1
 1529 008a 7B69     	 ldr r3,[r7,#20]
 1530 008c 002B     	 cmp r3,#0
 1531 008e F3D1     	 bne .L113
1110:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
1111:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1112:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* PCB not yet on the list, add PCB now */
1113:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->next = udp_pcbs;
 1532              	 .loc 1 1113 0 is_stmt 1
 1533 0090 064B     	 ldr r3,.L114
 1534 0092 1A68     	 ldr r2,[r3]
 1535 0094 FB68     	 ldr r3,[r7,#12]
 1536 0096 DA60     	 str r2,[r3,#12]
1114:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udp_pcbs = pcb;
 1537              	 .loc 1 1114 0
 1538 0098 044A     	 ldr r2,.L114
 1539 009a FB68     	 ldr r3,[r7,#12]
 1540 009c 1360     	 str r3,[r2]
1115:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return ERR_OK;
 1541              	 .loc 1 1115 0
 1542 009e 0023     	 movs r3,#0
 1543              	.L106:
 1544 00a0 5BB2     	 sxtb r3,r3
1116:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1545              	 .loc 1 1116 0
 1546 00a2 1846     	 mov r0,r3
 1547 00a4 1837     	 adds r7,r7,#24
 1548              	.LCFI53:
 1549              	 .cfi_def_cfa_offset 8
 1550 00a6 BD46     	 mov sp,r7
 1551              	.LCFI54:
 1552              	 .cfi_def_cfa_register 13
 1553              	 
 1554 00a8 80BD     	 pop {r7,pc}
 1555              	.L115:
 1556 00aa 00BF     	 .align 2
 1557              	.L114:
 1558 00ac 00000000 	 .word udp_pcbs
 1559              	 .cfi_endproc
 1560              	.LFE147:
 1562              	 .section .text.udp_disconnect,"ax",%progbits
 1563              	 .align 2
 1564              	 .global udp_disconnect
 1565              	 .thumb
 1566              	 .thumb_func
 1568              	udp_disconnect:
 1569              	.LFB148:
1117:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1118:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1119:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1120:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Remove the remote end of the pcb. This function does not generate
1121:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * any network traffic, but only removes the remote address of the pcb.
1122:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1123:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb the udp pcb to disconnect.
1124:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1125:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
1126:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_disconnect(struct udp_pcb *pcb)
1127:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1570              	 .loc 1 1127 0
 1571              	 .cfi_startproc
 1572              	 
 1573              	 
 1574              	 
 1575 0000 80B4     	 push {r7}
 1576              	.LCFI55:
 1577              	 .cfi_def_cfa_offset 4
 1578              	 .cfi_offset 7,-4
 1579 0002 83B0     	 sub sp,sp,#12
 1580              	.LCFI56:
 1581              	 .cfi_def_cfa_offset 16
 1582 0004 00AF     	 add r7,sp,#0
 1583              	.LCFI57:
 1584              	 .cfi_def_cfa_register 7
 1585 0006 7860     	 str r0,[r7,#4]
1128:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1129:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1130:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_disconnect: invalid pcb", pcb != NULL, return);
 1586              	 .loc 1 1130 0
 1587 0008 7B68     	 ldr r3,[r7,#4]
 1588 000a 002B     	 cmp r3,#0
 1589 000c 00D1     	 bne .L117
 1590 000e 0FE0     	 b .L116
 1591              	.L117:
1131:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1132:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* reset remote address association */
1133:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1134:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
1135:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
1136:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
1137:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif
1138:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
 1592              	 .loc 1 1138 0
 1593 0010 7B68     	 ldr r3,[r7,#4]
 1594 0012 0022     	 movs r2,#0
 1595 0014 5A60     	 str r2,[r3,#4]
1139:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1140:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1141:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif
1142:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->remote_port = 0;
 1596              	 .loc 1 1142 0
 1597 0016 7B68     	 ldr r3,[r7,#4]
 1598 0018 0022     	 movs r2,#0
 1599 001a 9A82     	 strh r2,[r3,#20]
1143:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->netif_idx = NETIF_NO_INDEX;
 1600              	 .loc 1 1143 0
 1601 001c 7B68     	 ldr r3,[r7,#4]
 1602 001e 0022     	 movs r2,#0
 1603 0020 1A72     	 strb r2,[r3,#8]
1144:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* mark PCB as unconnected */
1145:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
 1604              	 .loc 1 1145 0
 1605 0022 7B68     	 ldr r3,[r7,#4]
 1606 0024 1B7C     	 ldrb r3,[r3,#16]
 1607 0026 23F00403 	 bic r3,r3,#4
 1608 002a DAB2     	 uxtb r2,r3
 1609 002c 7B68     	 ldr r3,[r7,#4]
 1610 002e 1A74     	 strb r2,[r3,#16]
 1611              	.L116:
1146:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1612              	 .loc 1 1146 0
 1613 0030 0C37     	 adds r7,r7,#12
 1614              	.LCFI58:
 1615              	 .cfi_def_cfa_offset 4
 1616 0032 BD46     	 mov sp,r7
 1617              	.LCFI59:
 1618              	 .cfi_def_cfa_register 13
 1619              	 
 1620 0034 5DF8047B 	 ldr r7,[sp],#4
 1621              	.LCFI60:
 1622              	 .cfi_restore 7
 1623              	 .cfi_def_cfa_offset 0
 1624 0038 7047     	 bx lr
 1625              	 .cfi_endproc
 1626              	.LFE148:
 1628 003a 00BF     	 .section .text.udp_recv,"ax",%progbits
 1629              	 .align 2
 1630              	 .global udp_recv
 1631              	 .thumb
 1632              	 .thumb_func
 1634              	udp_recv:
 1635              	.LFB149:
1147:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1148:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1149:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1150:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Set a receive callback for a UDP PCB.
1151:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * This callback will be called when receiving a datagram for the pcb.
1152:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1153:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb the pcb for which to set the recv callback
1154:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param recv function pointer of the callback function
1155:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param recv_arg additional argument to pass to the callback function
1156:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1157:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
1158:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
1159:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1636              	 .loc 1 1159 0
 1637              	 .cfi_startproc
 1638              	 
 1639              	 
 1640              	 
 1641 0000 80B4     	 push {r7}
 1642              	.LCFI61:
 1643              	 .cfi_def_cfa_offset 4
 1644              	 .cfi_offset 7,-4
 1645 0002 85B0     	 sub sp,sp,#20
 1646              	.LCFI62:
 1647              	 .cfi_def_cfa_offset 24
 1648 0004 00AF     	 add r7,sp,#0
 1649              	.LCFI63:
 1650              	 .cfi_def_cfa_register 7
 1651 0006 F860     	 str r0,[r7,#12]
 1652 0008 B960     	 str r1,[r7,#8]
 1653 000a 7A60     	 str r2,[r7,#4]
1160:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1161:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1162:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 1654              	 .loc 1 1162 0
 1655 000c FB68     	 ldr r3,[r7,#12]
 1656 000e 002B     	 cmp r3,#0
 1657 0010 00D1     	 bne .L120
 1658 0012 05E0     	 b .L119
 1659              	.L120:
1163:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1164:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* remember recv() callback and user data */
1165:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->recv = recv;
 1660              	 .loc 1 1165 0
 1661 0014 FB68     	 ldr r3,[r7,#12]
 1662 0016 BA68     	 ldr r2,[r7,#8]
 1663 0018 9A61     	 str r2,[r3,#24]
1166:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb->recv_arg = recv_arg;
 1664              	 .loc 1 1166 0
 1665 001a FB68     	 ldr r3,[r7,#12]
 1666 001c 7A68     	 ldr r2,[r7,#4]
 1667 001e DA61     	 str r2,[r3,#28]
 1668              	.L119:
1167:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1669              	 .loc 1 1167 0
 1670 0020 1437     	 adds r7,r7,#20
 1671              	.LCFI64:
 1672              	 .cfi_def_cfa_offset 4
 1673 0022 BD46     	 mov sp,r7
 1674              	.LCFI65:
 1675              	 .cfi_def_cfa_register 13
 1676              	 
 1677 0024 5DF8047B 	 ldr r7,[sp],#4
 1678              	.LCFI66:
 1679              	 .cfi_restore 7
 1680              	 .cfi_def_cfa_offset 0
 1681 0028 7047     	 bx lr
 1682              	 .cfi_endproc
 1683              	.LFE149:
 1685 002a 00BF     	 .section .text.udp_remove,"ax",%progbits
 1686              	 .align 2
 1687              	 .global udp_remove
 1688              	 .thumb
 1689              	 .thumb_func
 1691              	udp_remove:
 1692              	.LFB150:
1168:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1169:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1170:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1171:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Removes and deallocates the pcb.  
1172:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 
1173:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param pcb UDP PCB to be removed. The PCB is removed from the list of
1174:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * UDP PCB's and the data structure is freed from memory.
1175:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1176:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_new()
1177:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1178:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void
1179:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_remove(struct udp_pcb *pcb)
1180:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1693              	 .loc 1 1180 0
 1694              	 .cfi_startproc
 1695              	 
 1696              	 
 1697 0000 80B5     	 push {r7,lr}
 1698              	.LCFI67:
 1699              	 .cfi_def_cfa_offset 8
 1700              	 .cfi_offset 7,-8
 1701              	 .cfi_offset 14,-4
 1702 0002 84B0     	 sub sp,sp,#16
 1703              	.LCFI68:
 1704              	 .cfi_def_cfa_offset 24
 1705 0004 00AF     	 add r7,sp,#0
 1706              	.LCFI69:
 1707              	 .cfi_def_cfa_register 7
 1708 0006 7860     	 str r0,[r7,#4]
1181:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *pcb2;
1182:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1183:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1184:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1185:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 1709              	 .loc 1 1185 0
 1710 0008 7B68     	 ldr r3,[r7,#4]
 1711 000a 002B     	 cmp r3,#0
 1712 000c 00D1     	 bne .L123
 1713 000e 26E0     	 b .L122
 1714              	.L123:
1186:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1187:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   mib2_udp_unbind(pcb);
1188:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* pcb to be removed is first in list? */
1189:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (udp_pcbs == pcb) {
 1715              	 .loc 1 1189 0
 1716 0010 144B     	 ldr r3,.L130
 1717 0012 1A68     	 ldr r2,[r3]
 1718 0014 7B68     	 ldr r3,[r7,#4]
 1719 0016 9A42     	 cmp r2,r3
 1720 0018 05D1     	 bne .L125
1190:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* make list start at 2nd pcb */
1191:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udp_pcbs = udp_pcbs->next;
 1721              	 .loc 1 1191 0
 1722 001a 124B     	 ldr r3,.L130
 1723 001c 1B68     	 ldr r3,[r3]
 1724 001e DB68     	 ldr r3,[r3,#12]
 1725 0020 104A     	 ldr r2,.L130
 1726 0022 1360     	 str r3,[r2]
 1727 0024 17E0     	 b .L126
 1728              	.L125:
1192:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* pcb not 1st in list */
1193:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   } else {
1194:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1729              	 .loc 1 1194 0
 1730 0026 0F4B     	 ldr r3,.L130
 1731 0028 1B68     	 ldr r3,[r3]
 1732 002a FB60     	 str r3,[r7,#12]
 1733 002c 10E0     	 b .L127
 1734              	.L129:
1195:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* find pcb in udp_pcbs list */
1196:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (pcb2->next != NULL && pcb2->next == pcb) {
 1735              	 .loc 1 1196 0
 1736 002e FB68     	 ldr r3,[r7,#12]
 1737 0030 DB68     	 ldr r3,[r3,#12]
 1738 0032 002B     	 cmp r3,#0
 1739 0034 09D0     	 beq .L128
 1740              	 .loc 1 1196 0 is_stmt 0 discriminator 1
 1741 0036 FB68     	 ldr r3,[r7,#12]
 1742 0038 DA68     	 ldr r2,[r3,#12]
 1743 003a 7B68     	 ldr r3,[r7,#4]
 1744 003c 9A42     	 cmp r2,r3
 1745 003e 04D1     	 bne .L128
1197:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* remove pcb from list */
1198:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         pcb2->next = pcb->next;
 1746              	 .loc 1 1198 0 is_stmt 1
 1747 0040 7B68     	 ldr r3,[r7,#4]
 1748 0042 DA68     	 ldr r2,[r3,#12]
 1749 0044 FB68     	 ldr r3,[r7,#12]
 1750 0046 DA60     	 str r2,[r3,#12]
1199:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         break;
 1751              	 .loc 1 1199 0
 1752 0048 05E0     	 b .L126
 1753              	.L128:
1194:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* find pcb in udp_pcbs list */
 1754              	 .loc 1 1194 0 discriminator 2
 1755 004a FB68     	 ldr r3,[r7,#12]
 1756 004c DB68     	 ldr r3,[r3,#12]
 1757 004e FB60     	 str r3,[r7,#12]
 1758              	.L127:
1194:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* find pcb in udp_pcbs list */
 1759              	 .loc 1 1194 0 is_stmt 0 discriminator 1
 1760 0050 FB68     	 ldr r3,[r7,#12]
 1761 0052 002B     	 cmp r3,#0
 1762 0054 EBD1     	 bne .L129
 1763              	.L126:
1200:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
1201:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
1202:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1203:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   memp_free(MEMP_UDP_PCB, pcb);
 1764              	 .loc 1 1203 0 is_stmt 1
 1765 0056 0120     	 movs r0,#1
 1766 0058 7968     	 ldr r1,[r7,#4]
 1767 005a FFF7FEFF 	 bl memp_free
 1768              	.L122:
1204:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1769              	 .loc 1 1204 0
 1770 005e 1037     	 adds r7,r7,#16
 1771              	.LCFI70:
 1772              	 .cfi_def_cfa_offset 8
 1773 0060 BD46     	 mov sp,r7
 1774              	.LCFI71:
 1775              	 .cfi_def_cfa_register 13
 1776              	 
 1777 0062 80BD     	 pop {r7,pc}
 1778              	.L131:
 1779              	 .align 2
 1780              	.L130:
 1781 0064 00000000 	 .word udp_pcbs
 1782              	 .cfi_endproc
 1783              	.LFE150:
 1785              	 .section .text.udp_new,"ax",%progbits
 1786              	 .align 2
 1787              	 .global udp_new
 1788              	 .thumb
 1789              	 .thumb_func
 1791              	udp_new:
 1792              	.LFB151:
1205:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1206:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1207:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1208:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Creates a new UDP pcb which can be used for UDP communication. The
1209:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * pcb is not active until it has either been bound to a local address
1210:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * or connected to a remote address.
1211:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1212:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return The UDP PCB which was created. NULL if the PCB data structure
1213:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * could not be allocated.
1214:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1215:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_remove()
1216:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1217:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** struct udp_pcb *
1218:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_new(void)
1219:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1793              	 .loc 1 1219 0
 1794              	 .cfi_startproc
 1795              	 
 1796              	 
 1797 0000 80B5     	 push {r7,lr}
 1798              	.LCFI72:
 1799              	 .cfi_def_cfa_offset 8
 1800              	 .cfi_offset 7,-8
 1801              	 .cfi_offset 14,-4
 1802 0002 82B0     	 sub sp,sp,#8
 1803              	.LCFI73:
 1804              	 .cfi_def_cfa_offset 16
 1805 0004 00AF     	 add r7,sp,#0
 1806              	.LCFI74:
 1807              	 .cfi_def_cfa_register 7
1220:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *pcb;
1221:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1222:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1223:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1224:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 1808              	 .loc 1 1224 0
 1809 0006 0120     	 movs r0,#1
 1810 0008 FFF7FEFF 	 bl memp_malloc
 1811 000c 7860     	 str r0,[r7,#4]
1225:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   /* could allocate UDP PCB? */
1226:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb != NULL) {
 1812              	 .loc 1 1226 0
 1813 000e 7B68     	 ldr r3,[r7,#4]
 1814 0010 002B     	 cmp r3,#0
 1815 0012 07D0     	 beq .L133
1227:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
1228:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****      * which means checksum is generated over the whole datagram per default
1229:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****      * (recommended as default by RFC 3828). */
1230:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     /* initialize PCB to all zeroes */
1231:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     memset(pcb, 0, sizeof(struct udp_pcb));
 1816              	 .loc 1 1231 0
 1817 0014 7868     	 ldr r0,[r7,#4]
 1818 0016 0021     	 movs r1,#0
 1819 0018 2022     	 movs r2,#32
 1820 001a FFF7FEFF 	 bl memset
1232:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     pcb->ttl = UDP_TTL;
 1821              	 .loc 1 1232 0
 1822 001e 7B68     	 ldr r3,[r7,#4]
 1823 0020 FF22     	 movs r2,#255
 1824 0022 DA72     	 strb r2,[r3,#11]
 1825              	.L133:
1233:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
1234:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     udp_set_multicast_ttl(pcb, UDP_TTL);
1235:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
1236:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1237:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return pcb;
 1826              	 .loc 1 1237 0
 1827 0024 7B68     	 ldr r3,[r7,#4]
1238:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1828              	 .loc 1 1238 0
 1829 0026 1846     	 mov r0,r3
 1830 0028 0837     	 adds r7,r7,#8
 1831              	.LCFI75:
 1832              	 .cfi_def_cfa_offset 8
 1833 002a BD46     	 mov sp,r7
 1834              	.LCFI76:
 1835              	 .cfi_def_cfa_register 13
 1836              	 
 1837 002c 80BD     	 pop {r7,pc}
 1838              	 .cfi_endproc
 1839              	.LFE151:
 1841 002e 00BF     	 .section .text.udp_new_ip_type,"ax",%progbits
 1842              	 .align 2
 1843              	 .global udp_new_ip_type
 1844              	 .thumb
 1845              	 .thumb_func
 1847              	udp_new_ip_type:
 1848              	.LFB152:
1239:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1240:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /**
1241:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @ingroup udp_raw
1242:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * Create a UDP PCB for specific IP type.
1243:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * The pcb is not active until it has either been bound to a local address
1244:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * or connected to a remote address.
1245:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * 
1246:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param type IP address type, see @ref lwip_ip_addr_type definitions.
1247:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * If you want to listen to IPv4 and IPv6 (dual-stack) packets,
1248:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
1249:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @return The UDP PCB which was created. NULL if the PCB data structure
1250:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * could not be allocated.
1251:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1252:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @see udp_remove()
1253:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1254:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** struct udp_pcb *
1255:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** udp_new_ip_type(u8_t type)
1256:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1849              	 .loc 1 1256 0
 1850              	 .cfi_startproc
 1851              	 
 1852              	 
 1853 0000 80B5     	 push {r7,lr}
 1854              	.LCFI77:
 1855              	 .cfi_def_cfa_offset 8
 1856              	 .cfi_offset 7,-8
 1857              	 .cfi_offset 14,-4
 1858 0002 84B0     	 sub sp,sp,#16
 1859              	.LCFI78:
 1860              	 .cfi_def_cfa_offset 24
 1861 0004 00AF     	 add r7,sp,#0
 1862              	.LCFI79:
 1863              	 .cfi_def_cfa_register 7
 1864 0006 0346     	 mov r3,r0
 1865 0008 FB71     	 strb r3,[r7,#7]
1257:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *pcb;
1258:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1259:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
1260:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1261:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   pcb = udp_new();
 1866              	 .loc 1 1261 0
 1867 000a FFF7FEFF 	 bl udp_new
 1868 000e F860     	 str r0,[r7,#12]
1262:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1263:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (pcb != NULL) {
1264:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     IP_SET_TYPE_VAL(pcb->local_ip,  type);
1265:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     IP_SET_TYPE_VAL(pcb->remote_ip, type);
1266:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1267:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #else
1268:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   LWIP_UNUSED_ARG(type);
1269:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** #endif /* LWIP_IPV4 && LWIP_IPV6 */
1270:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   return pcb;
 1869              	 .loc 1 1270 0
 1870 0010 FB68     	 ldr r3,[r7,#12]
1271:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1871              	 .loc 1 1271 0
 1872 0012 1846     	 mov r0,r3
 1873 0014 1037     	 adds r7,r7,#16
 1874              	.LCFI80:
 1875              	 .cfi_def_cfa_offset 8
 1876 0016 BD46     	 mov sp,r7
 1877              	.LCFI81:
 1878              	 .cfi_def_cfa_register 13
 1879              	 
 1880 0018 80BD     	 pop {r7,pc}
 1881              	 .cfi_endproc
 1882              	.LFE152:
 1884 001a 00BF     	 .section .text.udp_netif_ip_addr_changed,"ax",%progbits
 1885              	 .align 2
 1886              	 .global udp_netif_ip_addr_changed
 1887              	 .thumb
 1888              	 .thumb_func
 1890              	udp_netif_ip_addr_changed:
 1891              	.LFB153:
1272:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1273:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** /** This function is called from netif.c when address is changed
1274:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  *
1275:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param old_addr IP address of the netif before change
1276:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  * @param new_addr IP address of the netif after change
1277:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****  */
1278:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
1279:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** {
 1892              	 .loc 1 1279 0
 1893              	 .cfi_startproc
 1894              	 
 1895              	 
 1896              	 
 1897 0000 80B4     	 push {r7}
 1898              	.LCFI82:
 1899              	 .cfi_def_cfa_offset 4
 1900              	 .cfi_offset 7,-4
 1901 0002 85B0     	 sub sp,sp,#20
 1902              	.LCFI83:
 1903              	 .cfi_def_cfa_offset 24
 1904 0004 00AF     	 add r7,sp,#0
 1905              	.LCFI84:
 1906              	 .cfi_def_cfa_register 7
 1907 0006 7860     	 str r0,[r7,#4]
 1908 0008 3960     	 str r1,[r7]
1280:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   struct udp_pcb *upcb;
1281:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** 
1282:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 1909              	 .loc 1 1282 0
 1910 000a 7B68     	 ldr r3,[r7,#4]
 1911 000c 002B     	 cmp r3,#0
 1912 000e 1ED0     	 beq .L137
 1913              	 .loc 1 1282 0 is_stmt 0 discriminator 1
 1914 0010 7B68     	 ldr r3,[r7,#4]
 1915 0012 1B68     	 ldr r3,[r3]
 1916 0014 002B     	 cmp r3,#0
 1917 0016 1AD0     	 beq .L137
 1918              	 .loc 1 1282 0 discriminator 2
 1919 0018 3B68     	 ldr r3,[r7]
 1920 001a 002B     	 cmp r3,#0
 1921 001c 17D0     	 beq .L137
 1922              	 .loc 1 1282 0 discriminator 3
 1923 001e 3B68     	 ldr r3,[r7]
 1924 0020 1B68     	 ldr r3,[r3]
 1925 0022 002B     	 cmp r3,#0
 1926 0024 13D0     	 beq .L137
1283:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 1927              	 .loc 1 1283 0 is_stmt 1
 1928 0026 0C4B     	 ldr r3,.L142
 1929 0028 1B68     	 ldr r3,[r3]
 1930 002a FB60     	 str r3,[r7,#12]
 1931 002c 0CE0     	 b .L139
 1932              	.L141:
1284:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* PCB bound to current local interface address? */
1285:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 1933              	 .loc 1 1285 0
 1934 002e FB68     	 ldr r3,[r7,#12]
 1935 0030 1A68     	 ldr r2,[r3]
 1936 0032 7B68     	 ldr r3,[r7,#4]
 1937 0034 1B68     	 ldr r3,[r3]
 1938 0036 9A42     	 cmp r2,r3
 1939 0038 03D1     	 bne .L140
1286:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         /* The PCB is bound to the old ipaddr and
1287:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****          * is set to bound to the new one instead */
1288:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****         ip_addr_copy(upcb->local_ip, *new_addr);
 1940              	 .loc 1 1288 0
 1941 003a 3B68     	 ldr r3,[r7]
 1942 003c 1A68     	 ldr r2,[r3]
 1943 003e FB68     	 ldr r3,[r7,#12]
 1944 0040 1A60     	 str r2,[r3]
 1945              	.L140:
1283:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* PCB bound to current local interface address? */
 1946              	 .loc 1 1283 0 discriminator 2
 1947 0042 FB68     	 ldr r3,[r7,#12]
 1948 0044 DB68     	 ldr r3,[r3,#12]
 1949 0046 FB60     	 str r3,[r7,#12]
 1950              	.L139:
1283:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       /* PCB bound to current local interface address? */
 1951              	 .loc 1 1283 0 is_stmt 0 discriminator 1
 1952 0048 FB68     	 ldr r3,[r7,#12]
 1953 004a 002B     	 cmp r3,#0
 1954 004c EFD1     	 bne .L141
 1955              	.L137:
1289:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****       }
1290:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****     }
1291:../Dave/Generated/ETH_LWIP/lwip/core/udp.c ****   }
1292:../Dave/Generated/ETH_LWIP/lwip/core/udp.c **** }
 1956              	 .loc 1 1292 0 is_stmt 1
 1957 004e 1437     	 adds r7,r7,#20
 1958              	.LCFI85:
 1959              	 .cfi_def_cfa_offset 4
 1960 0050 BD46     	 mov sp,r7
 1961              	.LCFI86:
 1962              	 .cfi_def_cfa_register 13
 1963              	 
 1964 0052 5DF8047B 	 ldr r7,[sp],#4
 1965              	.LCFI87:
 1966              	 .cfi_restore 7
 1967              	 .cfi_def_cfa_offset 0
 1968 0056 7047     	 bx lr
 1969              	.L143:
 1970              	 .align 2
 1971              	.L142:
 1972 0058 00000000 	 .word udp_pcbs
 1973              	 .cfi_endproc
 1974              	.LFE153:
 1976              	 .text
 1977              	.Letext0:
 1978              	 .file 2 "d:\\program files\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1979              	 .file 3 "d:\\program files\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1980              	 .file 4 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/arch.h"
 1981              	 .file 5 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/err.h"
 1982              	 .file 6 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/pbuf.h"
 1983              	 .file 7 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/ip4_addr.h"
 1984              	 .file 8 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/ip_addr.h"
 1985              	 .file 9 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/memp.h"
 1986              	 .file 10 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/netif.h"
 1987              	 .file 11 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/prot/ip4.h"
 1988              	 .file 12 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/ip.h"
 1989              	 .file 13 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/prot/udp.h"
 1990              	 .file 14 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/udp.h"
 1991              	 .file 15 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Libraries/CMSIS/Include/cmsis_gcc.h"
 1992              	 .file 16 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Libraries/CMSIS/Include/core_cm4.h"
 1993              	 .file 17 "D:/Users/Beheerder/Desktop/GPSBox/SensorMaritime-SensorBox/Sensorbox_firmware/GPSGyroAnalysisTool/GpsGyroAnalysisTool/GpsGyroAnalysisTool/Dave/Generated/ETH_LWIP/lwip/include/lwip/icmp.h"
DEFINED SYMBOLS
                            *ABS*:00000000 udp.c
    {standard input}:20     .data.udp_port:00000000 $d
    {standard input}:23     .data.udp_port:00000000 udp_port
                            *COM*:00000004 udp_pcbs
    {standard input}:27     .text.udp_init:00000000 $t
    {standard input}:32     .text.udp_init:00000000 udp_init
    {standard input}:62     .text.udp_init:00000020 $d
    {standard input}:67     .text.udp_new_port:00000000 $t
    {standard input}:71     .text.udp_new_port:00000000 udp_new_port
    {standard input}:164    .text.udp_new_port:0000006c $d
    {standard input}:170    .text.udp_input_local_match:00000000 $t
    {standard input}:174    .text.udp_input_local_match:00000000 udp_input_local_match
    {standard input}:293    .text.udp_input_local_match:00000094 $d
    {standard input}:298    .text.udp_input:00000000 $t
    {standard input}:303    .text.udp_input:00000000 udp_input
    {standard input}:624    .text.udp_input:000001d8 $d
    {standard input}:631    .text.udp_send:00000000 $t
    {standard input}:636    .text.udp_send:00000000 udp_send
    {standard input}:701    .text.udp_sendto:00000000 udp_sendto
    {standard input}:696    .text.udp_sendto:00000000 $t
    {standard input}:804    .text.udp_sendto_if:00000000 udp_sendto_if
    {standard input}:799    .text.udp_sendto_if:00000000 $t
    {standard input}:930    .text.udp_sendto_if_src:00000000 udp_sendto_if_src
    {standard input}:925    .text.udp_sendto_if_src:00000000 $t
    {standard input}:1158   .text.udp_bind:00000000 udp_bind
    {standard input}:1153   .text.udp_bind:00000000 $t
    {standard input}:1350   .text.udp_bind:000000ec $d
    {standard input}:1356   .text.udp_bind_netif:00000000 $t
    {standard input}:1361   .text.udp_bind_netif:00000000 udp_bind_netif
    {standard input}:1415   .text.udp_connect:00000000 $t
    {standard input}:1420   .text.udp_connect:00000000 udp_connect
    {standard input}:1558   .text.udp_connect:000000ac $d
    {standard input}:1563   .text.udp_disconnect:00000000 $t
    {standard input}:1568   .text.udp_disconnect:00000000 udp_disconnect
    {standard input}:1629   .text.udp_recv:00000000 $t
    {standard input}:1634   .text.udp_recv:00000000 udp_recv
    {standard input}:1686   .text.udp_remove:00000000 $t
    {standard input}:1691   .text.udp_remove:00000000 udp_remove
    {standard input}:1781   .text.udp_remove:00000064 $d
    {standard input}:1786   .text.udp_new:00000000 $t
    {standard input}:1791   .text.udp_new:00000000 udp_new
    {standard input}:1842   .text.udp_new_ip_type:00000000 $t
    {standard input}:1847   .text.udp_new_ip_type:00000000 udp_new_ip_type
    {standard input}:1885   .text.udp_netif_ip_addr_changed:00000000 $t
    {standard input}:1890   .text.udp_netif_ip_addr_changed:00000000 udp_netif_ip_addr_changed
    {standard input}:1972   .text.udp_netif_ip_addr_changed:00000058 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
rand
ip_data
pbuf_free
ip4_addr_isbroadcast_u32
lwip_htons
pbuf_remove_header
pbuf_header_force
icmp_dest_unreach
netif_get_by_index
ip4_route
pbuf_add_header
pbuf_alloc
pbuf_chain
ip4_output_if_src
ip_addr_any
memp_free
memp_malloc
memset
